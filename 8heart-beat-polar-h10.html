<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Polar H10 ‚Äî Graphs + One-File CSV Logger</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22d3ee;
      --good: #34d399;
      --fair: #f59e0b;
      --poor: #f87171;
      --vector: #6366f1;
      --marker: #f87171;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 80% -10%, #1f2937 0, var(--bg) 40%);
      color: var(--text);
    }
    .wrap { max-width: 980px; margin: 32px auto; padding: 0 16px; }
    header { display:flex; align-items:center; gap:16px; margin-bottom: 16px; }
    h1 { font-size: clamp(22px, 3vw, 32px); line-height: 1.1; margin: 0; }
    .tag { padding: 4px 10px; border-radius: 999px; background: #0ea5e9; color:#002233; font-weight:700; font-size:12px; letter-spacing: .04em; }

    .panel { background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.15)); border: 1px solid rgba(255,255,255,.06); box-shadow: 0 10px 30px rgba(0,0,0,.35); border-radius: 16px; padding: 16px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 900px){ .grid{ grid-template-columns: 1.1fr .9fr; } }

    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    button{ appearance:none; border:1px solid rgba(255,255,255,.15); background: #111827; color: var(--text); border-radius: 12px; padding: 10px 14px; font-weight: 600; cursor: pointer; transition: .2s; }
    button:hover{ transform: translateY(-1px); border-color: rgba(34,211,238,.5); box-shadow: 0 8px 20px rgba(34,211,238,.15); }
    button:disabled{ opacity:.5; cursor:not-allowed; box-shadow:none; transform:none; }
    .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: var(--muted); }

    .statbox { display:flex; gap:20px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .stat { background: #0b1220; border: 1px solid rgba(255,255,255,.06); border-radius: 14px; padding: 14px 16px; flex:1; min-width: 220px; }
    .label { color: var(--muted); font-size: 12px; letter-spacing:.05em; text-transform: uppercase; }
    .value { font-size: 24px; font-weight: 800; }
    .value small{ font-size: 14px; font-weight: 600; color: var(--muted); }

    canvas { width: 100%; height: 220px; background: #0b1220; border:1px solid rgba(255,255,255,.06); border-radius: 12px; }
    #motionCanvas { height: 360px; }
    footer { margin-top: 24px; color: var(--muted); font-size: 12px; }
    a { color: var(--accent); }
    .tiny { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="tag">Web Bluetooth</div>
    <h1>Polar H10 ‚Üí Accelerometer Data Logger</h1>
  </header>

  <div class="panel">
    <div class="controls">
      <button id="connectBtn">üîó Connect H10</button>
      <button id="disconnectBtn" disabled>üîå Disconnect H10</button>

      <button id="saveAccBtn">üíæ Save Window (CSV)</button>
      <button id="startRecBtn" disabled>‚è∫Ô∏è Start Recording (CSV)</button>
      <button id="stopRecBtn" disabled>‚èπÔ∏è Stop Recording</button>
      <label class="tiny" style="display:flex;align-items:center;gap:6px">
        <span>Flush every</span>
        <input id="flushSec" type="number" min="1" value="1" style="width:64px; background:#111827; color:var(--text); border:1px solid rgba(255,255,255,.15); border-radius:8px; padding:6px 8px;" />
        <span>s</span>
      </label>

      <button id="debugBtn">üêõ Debug Info</button>
      <button id="retryBtn" disabled>üîÑ Retry Activation</button>
      <button id="resetMotionBtn" disabled>üéØ Reset Motion Start</button>
      <div class="status" id="status">Checking support‚Ä¶</div>
    </div>

    <div class="statbox" style="margin-top:12px">
      <div class="stat">
        <div class="label">Acceleration</div>
        <div class="value" id="accVal">‚Äî <small>g</small></div>
      </div>
      <div class="stat">
        <div class="label">Motion Distance (XY)</div>
        <div class="value" id="motionDistVal">0.00 <small>m</small></div>
      </div>
      <div class="stat">
        <div class="label">Position (X,Y)</div>
        <div class="value" id="motionPosVal"><span class="mono">0.00 m</span>, <span class="mono">0.00 m</span></div>
      </div>
    </div>

    <div class="grid" style="margin-top: 8px">
      <div>
        <div class="label">Accelerometry (X axis)</div>
        <canvas id="accxCanvas" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (Y axis)</div>
        <canvas id="accyCanvas" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (Z axis)</div>
        <canvas id="acczCanvas" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (magnitude)</div>
        <canvas id="accmCanvas" width="640" height="220"></canvas>
      </div>
      <div style="grid-column: 1 / -1;">
        <div class="label">Live Motion (XY) ‚Äî starts at (0,0) on reset</div>
        <canvas id="motionCanvas" width="960" height="360"></canvas>
        <div class="tiny" style="color:var(--muted); margin-top:6px;">
          Motion is estimated by subtracting a 1-second baseline (gravity/bias) after you click <em>Reset Motion Start</em>, then integrating acceleration twice (to velocity and position). Expect drift over time.
        </div>
      </div>
    </div>

    <div class="statbox" style="margin-top:12px">
      <div class="stat">
        <div class="label">Data Points</div>
        <div class="value" id="dataCountVal">0 <small>samples</small></div>
      </div>
      <div class="stat">
        <div class="label">Collection Time</div>
        <div class="value" id="collectionTimeVal">0 <small>minutes</small></div>
      </div>
      <div class="stat">
        <div class="label">Data Rate</div>
        <div class="value" id="dataRateVal">0 <small>Hz</small></div>
      </div>
      <div class="stat">
        <div class="label">Recording</div>
        <div class="value" id="recStateVal">No</div>
      </div>
    </div>

    <footer>
      <p>Use <strong>Chrome</strong> or <strong>Edge</strong> in a <strong>secure context</strong> (HTTPS or <code>http://localhost</code>). Keep your computer awake for long sessions.</p>
    </footer>
  </div>
</div>

<script>
// ================== Config ==================
const HR_SERVICE_UUID = 0x180D;
const HR_MEAS_UUID    = 0x2A37;

const PMD_SERVICE_UUID = 'fb005c80-02e7-f387-1cad-8acd2d8df0c8';
const PMD_CHAR1_UUID = 'fb005c81-02e7-f387-1cad-8acd2d8df0c8';
const PMD_CHAR2_UUID = 'fb005c82-02e7-f387-1cad-8acd2d8df0c8';

// Polar ACC: 200 Hz, 16-bit
const ACC_WRITE = new Uint8Array([
  0x02, 0x02, 0x00, 0x01,
  0xC8, 0x00, 0x01, 0x01,
  0x10, 0x00, 0x02, 0x01,
  0x08, 0x00
]);

// ===== Visualization window (keep memory bounded) =====
const VIS_WINDOW_SEC = 180; // 3 minutes retained for charts (file logs everything)

// ================== State ==================
let device = null;
let server = null;
let dataChar = null;
// include click flag per sample
let accBuffer = []; // {t,x,y,z,m,click}
let startTime = null;
let lastDataCount = 0;
let lastDataTime = 0;
let rawDataCount = 0;
let updateTimer = null;
let uiTimer = null;

// ---------- Recording (single-file streaming) ----------
let recording = false;
let recHandle = null;        // FileSystemFileHandle
let recWriter = null;        // FileSystemWritableFileStream
let recBuffer = '';
let recordedSamples = 0;
let recFlushEveryMs = 1000;
let lastFlush = 0;
let wakeLock = null;
let reopenTimer = null;
let chunkIndex = 1;          // fallback chunk numbering

// ----- Motion Estimation State -----
const G = 9.80665;                 // m/s^2 per 1g
let baselineCollecting = false;
let baselineReady = false;
let baselineSamples = [];
const BASELINE_SEC = 1.0;
const TARGET_FS = 200;
const BASELINE_COUNT = Math.round(BASELINE_SEC * TARGET_FS);

let baselineAcc = {x:0, y:0, z:0}; // in g
let vel = {x:0, y:0, z:0};         // m/s
let pos = {x:0, y:0, z:0};         // meters
let lastSampleTime = null;         // seconds
let motionPath = [{x:0,y:0}];      // meters
const MOTION_MAX_POINTS = 20000;
const VEL_DAMP_PER_SAMPLE = 0.97;
const DB_LO = 0.02;
const DB_HI = 0.06;
const ZUPT_SAMPLES = 30;
const VEL_EPS = 0.008;
const ORIGIN_SNAP_RADIUS = 0.08;
const GRAV_TAU = 0.8;

let prevAcc = {x:0, y:0, z:0};
let zuptCounter = 0;
let gEst = {x:0, y:0, z:1}; // in g

// ---- Marker state (space bar -> tag next sample) ----
let pendingMarkerCount = 0;

// ================== UI Elements ==================
const statusEl = document.getElementById('status');

const accVal = document.getElementById('accVal');
const dataCountVal = document.getElementById('dataCountVal');
const collectionTimeVal = document.getElementById('collectionTimeVal');
const dataRateVal = document.getElementById('dataRateVal');
const motionDistVal = document.getElementById('motionDistVal');
const motionPosVal = document.getElementById('motionPosVal');
const recStateVal = document.getElementById('recStateVal');

const accxCanvas = document.getElementById('accxCanvas');
const accyCanvas = document.getElementById('accyCanvas');
const acczCanvas = document.getElementById('acczCanvas');
const accmCanvas = document.getElementById('accmCanvas');
const motionCanvas = document.getElementById('motionCanvas');

const accxctx = accxCanvas.getContext('2d');
const accyctx = accyCanvas.getContext('2d');
const acczctx = acczCanvas.getContext('2d');
const accmctx = accmCanvas.getContext('2d');
const motionctx = motionCanvas.getContext('2d');

// ================== Helpers ==================
function setStatus(msg){ statusEl.textContent = msg; }
function setRec(val){ recStateVal.textContent = val ? 'Yes' : 'No'; }

function softDeadband(a){
  const s = Math.sign(a);
  const aa = Math.abs(a);
  if (aa < DB_LO) return 0;
  return s * (aa - DB_LO);
}

// --- Recording helpers (File System Access API) ---
async function acquireWakeLock(){
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', ()=>console.log('Wake lock released'));
    }
  } catch (e) {
    console.warn('Wake lock not available:', e);
  }
}

async function openWriter(){
  recWriter = await recHandle.createWritable({ keepExistingData:true });
  const f = await recHandle.getFile();
  await recWriter.seek(f.size);
}

async function startRecording(){
  if (recording) return;
  if (!server || !dataChar){ alert('Connect to the H10 first.'); return; }
  if (!('showSaveFilePicker' in window)){
    setStatus('Single-file recording needs Chrome/Edge on HTTPS (or http://localhost). Falling back to chunk downloads.');
  }
  try{
    recFlushEveryMs = Math.max(1, Number(document.getElementById('flushSec').value || 1)) * 1000;

    if ('showSaveFilePicker' in window){
      recHandle = await window.showSaveFilePicker({
        suggestedName: `polar_h10_acc_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`,
        types: [{ description: 'CSV', accept: { 'text/csv': ['.csv'] } }]
      });
      await openWriter();
      const existing = await recHandle.getFile();
      if (existing.size === 0){ await recWriter.write('timestamp,x,y,z,magnitude,click\n'); }
    } else {
      // fallback header will be injected on first flush
      recBuffer = 'timestamp,x,y,z,magnitude,click\n';
    }

    await acquireWakeLock();
    recording = true;
    recordedSamples = 0;
    lastFlush = performance.now();
    startRecBtn.disabled = true;
    stopRecBtn.disabled = false;
    setRec(true);
    setStatus('Recording‚Ä¶ writing CSV batches');

    if ('showSaveFilePicker' in window){
      reopenTimer = setInterval(commitAndReopen, 10 * 60 * 1000);
    }
  } catch(err){
    console.error('startRecording failed:', err);
    setStatus('Recording not started: ' + err.message);
  }
}

async function stopRecording(){
  if (!recording) return;
  try{
    if (reopenTimer) { clearInterval(reopenTimer); reopenTimer = null; }
    await flushRecording(true);
    if (recWriter){ await recWriter.close(); recWriter = null; }
    if (wakeLock) { try { await wakeLock.release(); } catch {} wakeLock = null; }
    recording = false;
    startRecBtn.disabled = false;
    stopRecBtn.disabled = true;
    setRec(false);
    setStatus(`Recording stopped. ${recordedSamples} samples saved.`);
  } catch(err){
    console.error('stopRecording failed:', err);
    setStatus('Error stopping recording: ' + err.message);
  }
}

async function commitAndReopen(){
  try{
    await flushRecording(true);
    if (recWriter){ await recWriter.close(); }
    await openWriter();
  } catch (e){ console.error('commit cycle error', e); }
}

async function flushRecording(force=false){
  const now = performance.now();
  if (!recording) return;
  if (!force && (now - lastFlush < recFlushEveryMs) && recBuffer.length < 1_000_000) return;
  lastFlush = now;
  if (recWriter){
    if (recBuffer.length){ await recWriter.write(recBuffer); recBuffer = ''; }
  } else {
    if (recBuffer.length > 0){
      const blob = new Blob([recBuffer], {type:'text/csv;charset=utf-8;'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `polar_h10_chunk_${String(chunkIndex++).padStart(3,'0')}.csv`;
      document.body.appendChild(a); a.click(); document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
      recBuffer = 'timestamp,x,y,z,magnitude,click\n';
    }
  }
}

// --- Motion helpers ---
function resetMotion(){
  baselineCollecting = true;
  baselineReady = false;
  baselineSamples = [];
  baselineAcc = {x:0,y:0,z:0};
  vel = {x:0,y:0,z:0};
  pos = {x:0,y:0,z:0};
  motionPath = [{x:0,y:0}];
  lastSampleTime = null;
  setStatus('Motion reset: hold steady ~1s to capture baseline‚Ä¶');
}

function addToBaseline(sampleG){
  baselineSamples.push({x:sampleG.x, y:sampleG.y, z:sampleG.z});
  if (baselineSamples.length >= BASELINE_COUNT){
    const sum = baselineSamples.reduce((a,s)=>({x:a.x+s.x, y:a.y+s.y, z:a.z+s.z}), {x:0,y:0,z:0});
    baselineAcc = { x: sum.x / baselineSamples.length, y: sum.y / baselineSamples.length, z: sum.z / baselineSamples.length };
    gEst = {x: baselineAcc.x, y: baselineAcc.y, z: baselineAcc.z};
    baselineCollecting = false;
    baselineReady = true;
    setStatus('Baseline captured. Tracking motion from (0,0).');
  }
}

function processMotionSample(sample, t){
  if (baselineCollecting){ addToBaseline(sample); return; }
  if (!baselineReady) return;

  if (lastSampleTime == null){ lastSampleTime = t; return; }
  let dt = t - lastSampleTime;
  if (dt <= 0 || dt > 0.2){ dt = 1 / TARGET_FS; }
  lastSampleTime = t;

  const alpha = Math.exp(-dt / GRAV_TAU);
  gEst.x = alpha * gEst.x + (1 - alpha) * sample.x;
  gEst.y = alpha * gEst.y + (1 - alpha) * sample.y;
  gEst.z = alpha * gEst.z + (1 - alpha) * sample.z;

  let ax = (sample.x - gEst.x) * G;
  let ay = (sample.y - gEst.y) * G;
  let az = (sample.z - gEst.z) * G;

  const moving = (Math.abs(ax) > DB_HI) || (Math.abs(ay) > DB_HI) || (Math.abs(az) > DB_HI);
  ax = softDeadband(ax); ay = softDeadband(ay); az = softDeadband(az);

  if (ax === 0 && ay === 0 && az === 0) { zuptCounter++; } else { zuptCounter = 0; }

  let vxNew = vel.x + 0.5 * (prevAcc.x + ax) * dt;
  let vyNew = vel.y + 0.5 * (prevAcc.y + ay) * dt;
  let vzNew = vel.z + 0.5 * (prevAcc.z + az) * dt;

  vxNew *= VEL_DAMP_PER_SAMPLE; vyNew *= VEL_DAMP_PER_SAMPLE; vzNew *= VEL_DAMP_PER_SAMPLE;

  if (zuptCounter >= ZUPT_SAMPLES){
    vxNew = 0; vyNew = 0; vzNew = 0;
    const a2 = 0.1;
    gEst.x = (1 - a2) * gEst.x + a2 * sample.x;
    gEst.y = (1 - a2) * gEst.y + a2 * sample.y;
    gEst.z = (1 - a2) * gEst.z + a2 * sample.z;
  }

  if (Math.abs(vxNew) < VEL_EPS) vxNew = 0;
  if (Math.abs(vyNew) < VEL_EPS) vyNew = 0;
  if (Math.abs(vzNew) < VEL_EPS) vzNew = 0;

  pos.x += 0.5 * (vel.x + vxNew) * dt;
  pos.y += 0.5 * (vel.y + vyNew) * dt;
  pos.z += 0.5 * (vel.z + vzNew) * dt;

  if (zuptCounter >= ZUPT_SAMPLES) {
    const dist0 = Math.hypot(pos.x, pos.y);
    if (dist0 <= ORIGIN_SNAP_RADIUS) { pos.x = 0; pos.y = 0; }
  }

  vel.x = vxNew; vel.y = vyNew; vel.z = vzNew;
  prevAcc.x = ax; prevAcc.y = ay; prevAcc.z = az;

  motionPath.push({x: pos.x, y: pos.y});
  if (motionPath.length > MOTION_MAX_POINTS) motionPath.shift();
}

// === Drawing ===
function drawSeries(ctx, data, markers = []){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.save();
  ctx.translate(60,10);
  const iw = w - 70, ih = h - 50;

  // grid
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  for (let i=0;i<5;i++){
    const y = 10 + i*(ih/4);
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(iw,y); ctx.stroke();
  }
  for (let i=0;i<5;i++){
    const x = i*(iw/4);
    ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,ih+10); ctx.stroke();
  }

  if (!data || data.x.length<2){
    ctx.restore(); return;
  }

  const x = data.x, y = data.y;
  const xmin = Math.min(...x), xmax = Math.max(...x);
  const ymin = Math.min(...y), ymax = Math.max(...y);

  const sx = v => (v - xmin) / (xmax - xmin + 1e-9) * iw;
  const sy = v => ih - (v - ymin) / (ymax - ymin + 1e-9) * ih;

  const fmt = (val, range)=>{
    const r = Math.abs(range);
    if (!isFinite(r) || r < 1e-9) return val.toFixed(3);
    if (r < 0.5) return val.toFixed(3);
    if (r < 5) return val.toFixed(2);
    if (r < 50) return val.toFixed(1);
    return Math.round(val).toString();
  };
  ctx.fillStyle = 'rgba(148,163,184,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (let i=0;i<5;i++){
    const gy = 10 + i*(ih/4);
    const yval = ymax - (i/4)*(ymax - ymin);
    ctx.fillText(fmt(yval, ymax - ymin), -6, gy);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for (let i=0;i<5;i++){
    const gx = i*(iw/4);
    const xval = xmin + (i/4)*(xmax - xmin);
    ctx.fillText(fmt(xval, xmax - xmin), gx, ih + 20);
  }

  // series
  ctx.strokeStyle = 'rgba(34,211,238,0.9)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(sx(x[0]), sy(y[0]));
  for (let i=1;i<x.length;i++) ctx.lineTo(sx(x[i]), sy(y[i]));
  ctx.stroke();

  // markers (vertical red lines)
  if (markers && markers.length){
    ctx.strokeStyle = 'rgba(248,113,113,0.95)'; // --marker
    ctx.lineWidth = 2;
    for (const mt of markers){
      if (mt < xmin || mt > xmax) continue;
      const mx = sx(mt);
      ctx.beginPath();
      ctx.moveTo(mx, 10);
      ctx.lineTo(mx, ih + 10);
      ctx.stroke();
    }
  }

  ctx.restore();
}

function drawMotion(ctx, path){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  const margin = 20; const iw = w - margin*2; const ih = h - margin*2;
  ctx.save(); ctx.translate(margin, margin);
  ctx.strokeStyle = 'rgba(255,255,255,0.12)'; ctx.lineWidth = 1;
  for (let i=0;i<=4;i++){ const x=i*(iw/4), y=i*(ih/4); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,ih); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(iw,y); ctx.stroke(); }
  if (!path || path.length < 2){ ctx.restore(); return; }
  let xmin=Infinity,xmax=-Infinity,ymin=Infinity,ymax=-Infinity;
  for (const p of path){ if (!isFinite(p.x)||!isFinite(p.y)) continue; if (p.x<xmin) xmin=p.x; if (p.x>xmax) xmax=p.x; if (p.y<ymin) ymin=p.y; if (p.y>ymax) ymax=p.y; }
  if (!isFinite(xmin)){ xmin=-1; xmax=1; ymin=-1; ymax=1; }
  const xpad=(xmax-xmin)*0.15+0.01, ypad=(ymax-ymin)*0.15+0.01; xmin-=xpad; xmax+=xpad; ymin-=ypad; ymax+=ypad;
  const xrange=xmax-xmin, yrange=ymax-ymin; const scale=Math.min(iw/(xrange||1), ih/(yrange||1));
  const xoff=(iw - scale*xrange)/2, yoff=(ih - scale*yrange)/2;
  const sx=v=> xoff + (v - xmin) * scale; const sy=v=> ih - (yoff + (v - ymin) * scale);
  ctx.strokeStyle = 'rgba(148,163,184,0.35)'; ctx.beginPath(); ctx.moveTo(sx(0),0); ctx.lineTo(sx(0),ih); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,sy(0)); ctx.lineTo(iw,sy(0)); ctx.stroke();
  ctx.strokeStyle = 'rgba(34,211,238,0.9)'; ctx.lineWidth=2; ctx.beginPath(); let started=false; for (const p of path){ const px=sx(p.x), py=sy(p.y); if (!started){ ctx.moveTo(px,py); started=true; } else ctx.lineTo(px,py);} ctx.stroke();
  const start=path[0]; ctx.fillStyle='rgba(52,211,153,0.95)'; ctx.beginPath(); ctx.arc(sx(start.x), sy(start.y), 4, 0, Math.PI*2); ctx.fill();
  const end=path[path.length-1]; ctx.fillStyle='rgba(245,158,11,0.95)'; ctx.beginPath(); ctx.arc(sx(end.x), sy(end.y), 4, 0, Math.PI*2); ctx.fill();
  ctx.save(); ctx.setLineDash([6,6]); ctx.strokeStyle='rgba(99,102,241,0.9)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(sx(0), sy(0)); ctx.lineTo(sx(end.x), sy(end.y)); ctx.stroke(); ctx.restore();
  ctx.fillStyle='rgba(148,163,184,0.95)'; ctx.font='12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'; ctx.textAlign='center'; ctx.fillText(`[${end.x.toFixed(2)}, ${end.y.toFixed(2)}] m`, sx(end.x), sy(end.y) - 12); ctx.fillText('(0,0)', sx(0), sy(0) - 8);
  ctx.restore();
}

function parseAcc(dataView){
  const samples = [];
  if (dataView.byteLength < 10) return samples;
  const accuracy = dataView.getUint8(9);
  let sampleSize = 6; let offset = 10;
  if (accuracy === 0x00){ sampleSize = 3; }
  for (let i = offset; i + sampleSize - 1 < dataView.byteLength; i += sampleSize){
    let x,y,z;
    if (sampleSize === 3){ x = dataView.getInt8(i) / 1000.0; y = dataView.getInt8(i+1) / 1000.0; z = dataView.getInt8(i+2) / 1000.0; }
    else { x = dataView.getInt16(i, true) / 1000.0; y = dataView.getInt16(i+2, true) / 1000.0; z = dataView.getInt16(i+4, true) / 1000.0; }
    const m = Math.sqrt(x*x + y*y + z*z);
    samples.push({x,y,z,m});
  }
  return samples;
}

function parsePMD(dataView){
  if (dataView.byteLength < 9) return null;
  const frametype = dataView.getUint8(0);
  const timestamp = dataView.getBigUint64(1, true);
  if (frametype === 0x02 || frametype === 0x00){
    const accSamples = parseAcc(dataView);
    if (accSamples.length) return {timestamp, accSamples};
  }
  return null;
}

function keepWindow(){
  while (accBuffer.length && accBuffer[0].t < accBuffer[accBuffer.length-1].t - VIS_WINDOW_SEC){ accBuffer.shift(); }
}

function saveAccelerometerData(){
  if (!accBuffer || accBuffer.length === 0){ alert('No accelerometer data to save'); return; }
  let csvContent = 'timestamp,x,y,z,magnitude,click\n';
  accBuffer.forEach(s => { csvContent += `${s.t},${s.x},${s.y},${s.z},${s.m},${s.click?1:0}\n`; });
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `accelerometer_window_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setStatus(`Saved ${accBuffer.length} samples from the window to CSV`);
}

function showDebugInfo(){
  console.log('Device connected:', !!device);
  console.log('Server connected:', !!server);
  console.log('Data characteristic:', !!dataChar);
  console.log('Raw frames:', rawDataCount);
  console.log('Window samples:', accBuffer.length);
  console.log('Recording:', recording, 'recordedSamples:', recordedSamples);
  console.log('Pending marker count:', pendingMarkerCount);
  const clicks = accBuffer.filter(s=>s.click).length;
  console.log('Markers in window:', clicks);
  alert('Debug info printed to console.');
}

async function retryActivation(){
  if (!device || !server) { alert('Not connected to device'); return; }
  setStatus('Retrying activation methods‚Ä¶');
  try {
    const pmdSvc = await server.getPrimaryService(PMD_SERVICE_UUID);
    const ctrlChar = await pmdSvc.getCharacteristic(PMD_CHAR1_UUID);
    rawDataCount = 0;
    await ctrlChar.writeValueWithResponse(ACC_WRITE);
    await new Promise(r => setTimeout(r, 1000));
    const altCommand = new Uint8Array([0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00]);
    await ctrlChar.writeValueWithResponse(altCommand);
    await new Promise(r => setTimeout(r, 1000));
    const combined = new Uint8Array([0x02,0x00,0x00,0x01,0x82,0x00,0x01,0x01,0x0E,0x00, 0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00, 0x02,0x01,0x08,0x00]);
    await ctrlChar.writeValueWithResponse(combined);
    setStatus('Retry complete.');
  } catch (err) {
    console.error('Retry failed:', err);
    setStatus('Retry failed: ' + err.message);
  }
}

function updateUI(){
  if (accBuffer.length > 0){
    const latest = accBuffer[accBuffer.length - 1];
    accVal.innerHTML = latest.m.toFixed(2) + ' <small>g</small>';
  } else {
    accVal.innerHTML = '‚Äî <small>g</small>';
  }

  if (motionPath.length){
    const p = motionPath[motionPath.length-1];
    const dist = Math.hypot(p.x, p.y);
    motionDistVal.innerHTML = dist.toFixed(2) + ' <small>m</small>';
    motionPosVal.innerHTML = `<span class="mono">${p.x.toFixed(2)} m</span>, <span class="mono">${p.y.toFixed(2)} m</span>`;
  } else {
    motionDistVal.innerHTML = '0.00 <small>m</small>';
    motionPosVal.innerHTML = '<span class="mono">0.00 m</span>, <span class="mono">0.00 m</span>';
  }

  dataCountVal.innerHTML = accBuffer.length + ' <small>samples</small>';

  if (startTime) {
    const elapsed = (Date.now() / 1000) - startTime;
    const minutes = Math.floor(elapsed / 60);
    collectionTimeVal.innerHTML = minutes + ' <small>minutes</small>';
  } else { collectionTimeVal.innerHTML = '0 <small>minutes</small>'; }

  const currentTime = Date.now() / 1000;
  if (lastDataTime > 0 && currentTime > lastDataTime) {
    const timeDiff = currentTime - lastDataTime;
    const dataDiff = accBuffer.length - lastDataCount;
    const dataRate = dataDiff / timeDiff;
    dataRateVal.innerHTML = dataRate.toFixed(1) + ' <small>Hz</small>';
  } else { dataRateVal.innerHTML = '0.0 <small>Hz</small>'; }
  lastDataCount = accBuffer.length; lastDataTime = currentTime;

  // draw series with markers
  const t = accBuffer.map(p => p.t);
  const markerTs = accBuffer.filter(p => p.click).map(p => p.t);

  if (t.length >= 2){
    drawSeries(accxctx, { x:t, y:accBuffer.map(p=>p.x) }, markerTs);
    drawSeries(accyctx, { x:t, y:accBuffer.map(p=>p.y) }, markerTs);
    drawSeries(acczctx, { x:t, y:accBuffer.map(p=>p.z) }, markerTs);
    drawSeries(accmctx, { x:t, y:accBuffer.map(p=>p.m) }, markerTs);
  } else {
    drawSeries(accxctx, {x:[], y:[]}, []);
    drawSeries(accyctx, {x:[], y:[]}, []);
    drawSeries(acczctx, {x:[], y:[]}, []);
    drawSeries(accmctx, {x:[], y:[]}, []);
  }

  drawMotion(motionctx, motionPath);
}

// ================== BLE Flow (FIXED: chooser + robust errors) ==================
async function forgetPreviouslyGrantedPolarDevices(){
  // Best-effort: clear previously granted Polar H10 permissions so chooser always appears
  try {
    if (!navigator.bluetooth.getDevices) return;
    const granted = await navigator.bluetooth.getDevices();
    await Promise.all(
      granted
        .filter(d => (/^Polar/i).test(d.name || ''))
        .map(d => d.forget?.())
        .filter(Boolean)
    );
  } catch (e) {
    // Non-fatal
    console.debug('forget() unsupported or failed:', e);
  }
}

async function connect(){
  try{
    setStatus('Opening device chooser‚Ä¶');

    // Ensure we always get a chooser instead of Chrome auto-reselecting the last device
    await forgetPreviouslyGrantedPolarDevices();

    device = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,                           // <-- force chooser
      optionalServices: [HR_SERVICE_UUID, PMD_SERVICE_UUID]
    });

    if (!device){ setStatus('No device selected.'); return; }

    if (!(/^Polar/i).test(device.name || '')){
      setStatus(`Selected "${device.name || 'Unknown'}" ‚Äî not a Polar device. Try again.`);
      return;
    }

    device.addEventListener('gattserverdisconnected', onDisconnected);

    setStatus(`Connecting to ${device.name || 'device'}‚Ä¶`);

    const connectPromise = device.gatt.connect();
    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), 10000));
    server = await Promise.race([connectPromise, timeoutPromise]);

    setStatus('Getting services‚Ä¶');

    // Device Info service sometimes stabilizes pairing on Polar devices
    try { await server.getPrimaryService('0000180a-0000-1000-8000-00805f9b34fb'); } catch {}

    // --- Heart Rate (kick notifications once to wake link on some OSes) ---
    try {
      const hrSvc = await server.getPrimaryService(HR_SERVICE_UUID);
      const hrChar = await hrSvc.getCharacteristic(HR_MEAS_UUID);
      try { await hrChar.startNotifications(); setTimeout(()=>{ try{ hrChar.stopNotifications(); }catch{} }, 1000); } catch {}
    } catch {}

    // --- Polar PMD (accelerometer) ---
    let pmdSvc;
    try {
      pmdSvc = await server.getPrimaryService(PMD_SERVICE_UUID);
    } catch (e) {
      setStatus('This device does not expose Polar PMD (accelerometer). It may be connected to another app or need a firmware update.');
      console.error('PMD service not found:', e);
      return;
    }

    const ctrlChar = await pmdSvc.getCharacteristic(PMD_CHAR1_UUID);

    setStatus('Starting accelerometer data stream‚Ä¶');

    // Primary activation
    await ctrlChar.writeValueWithResponse(ACC_WRITE);
    await new Promise(r => setTimeout(r, 1000));
    await ctrlChar.writeValueWithResponse(ACC_WRITE);
    await new Promise(r => setTimeout(r, 1500));

    dataChar = await pmdSvc.getCharacteristic(PMD_CHAR2_UUID);
    dataChar.addEventListener('characteristicvaluechanged', onPMD);
    await dataChar.startNotifications();
    await new Promise(r => setTimeout(r, 800));

    setStatus('Connected. Streaming accelerometer data‚Ä¶');
    connectBtn.disabled = true; disconnectBtn.disabled = false; retryBtn.disabled = false; resetMotionBtn.disabled = false; startRecBtn.disabled = false;
    startTime = Date.now() / 1000;

    if (updateTimer) clearInterval(updateTimer);
    if (uiTimer) clearInterval(uiTimer);
    updateTimer = setInterval(processStep, 1000);
    uiTimer = setInterval(updateUI, 100);

    resetMotion();

    // Fallback activation if no frames arrive
    setTimeout(async () => {
      if (rawDataCount === 0) {
        setStatus('Connected but no data yet. Trying alternative activation‚Ä¶');
        try {
          const alt = new Uint8Array([0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00]);
          await ctrlChar.writeValueWithResponse(alt);
          await new Promise(r => setTimeout(r, 1000));
          const combined = new Uint8Array([0x02,0x00,0x00,0x01,0x82,0x00,0x01,0x01,0x0E,0x00, 0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00, 0x02,0x01,0x08,0x00]);
          await ctrlChar.writeValueWithResponse(combined);
        } catch (e) {
          console.error('Alt activation failed:', e);
        }
      }
    }, 5000);

  } catch(err){
    console.error(err);
    if (err.name === 'NotFoundError') setStatus('Chooser closed or no device picked.');
    else if (err.name === 'SecurityError') setStatus('Error: Bluetooth access denied. Check site permissions.');
    else if (err.message === 'Connection timeout') setStatus('Error: Connection timeout. Is the strap already connected to a phone app?');
    else setStatus('Error: ' + err.message);
  }
}

function onDisconnected(){
  setStatus('Disconnected');
  connectBtn.disabled = false; disconnectBtn.disabled = true; retryBtn.disabled = true; resetMotionBtn.disabled = true; startRecBtn.disabled = true; stopRecBtn.disabled = true; setRec(false);
  try{ dataChar && dataChar.stopNotifications(); }catch{}
  if (updateTimer) clearInterval(updateTimer);
  if (uiTimer) clearInterval(uiTimer);
}

async function disconnect(){
  try{
    if (!device) return;
    if (dataChar){ try{ await dataChar.stopNotifications(); } catch(e){} }
    if (device.gatt.connected) device.gatt.disconnect();
  } catch(err){ console.error(err); }
}

function onPMD(event){
  try {
    const dv = event.target.value;
    rawDataCount++;
    const data = parsePMD(dv);
    if (!data) return;

    const tNow = Number(data.timestamp) / 1e9;
    const n = data.accSamples.length;

    for (let i = 0; i < n; i++){
      const s = data.accSamples[i];
      const t = tNow - (n - i - 1) / TARGET_FS; // spread samples evenly

      // SPACE marker: tag the *next* incoming sample(s)
      let click = 0;
      if (pendingMarkerCount > 0){
        click = 1;
        pendingMarkerCount--;
      }

      accBuffer.push({ t, x:s.x, y:s.y, z:s.z, m:s.m, click });
      if (recording){
        recBuffer += `${t},${s.x},${s.y},${s.z},${s.m},${click}\n`;
        recordedSamples++;
      }
      processMotionSample(s, t);
    }
    flushRecording();
  } catch (err) {
    console.error('onPMD processing error:', err);
    setStatus('Data processing error (see console).');
  }
}

function processStep(){ keepWindow(); }

window.addEventListener('error', (e)=>{ console.error('Global script error:', e.error || e.message); setStatus('Script error: check console.'); });

// Warn if closing while recording
window.addEventListener('beforeunload', (e)=>{ if (recording){ e.preventDefault(); e.returnValue=''; } });

// ======== NEW: Space bar marker handler ========
window.addEventListener('keydown', (e) => {
  // Ignore if focused in an input/textarea/contenteditable
  const el = document.activeElement;
  const isTyping = el && (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA' || el.isContentEditable);
  if (isTyping) return;
  if (e.code === 'Space'){
    e.preventDefault();
    pendingMarkerCount++;
    setStatus(`Marker queued (will tag the next sample). Pending: ${pendingMarkerCount}`);
  }
});

// ================== Events ==================
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const saveAccBtn = document.getElementById('saveAccBtn');
const startRecBtn = document.getElementById('startRecBtn');
const stopRecBtn  = document.getElementById('stopRecBtn');
const debugBtn = document.getElementById('debugBtn');
const retryBtn = document.getElementById('retryBtn');
const resetMotionBtn = document.getElementById('resetMotionBtn');

connectBtn.addEventListener('click', connect);
disconnectBtn.addEventListener('click', disconnect);
saveAccBtn.addEventListener('click', saveAccelerometerData);
startRecBtn.addEventListener('click', startRecording);
stopRecBtn.addEventListener('click', stopRecording);
debugBtn.addEventListener('click', showDebugInfo);
retryBtn.addEventListener('click', retryActivation);
resetMotionBtn.addEventListener('click', resetMotion);

// Feature detection & support message
(function initSupportMessage(){
  const isSecure = window.isSecureContext || location.protocol === 'https:' || location.hostname === 'localhost';
  if (!('bluetooth' in navigator) || !isSecure){
    setStatus('Web Bluetooth requires Chrome/Edge in a secure context (HTTPS or http://localhost).');
    connectBtn.disabled = true;
    return;
  }
  setStatus('Ready. Click Connect to pick your Polar H10 (chooser always opens). Press Space to drop markers.');
})();
</script>
</body>
</html>
