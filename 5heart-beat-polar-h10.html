<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Polar H10 ‚Äî One‚ÄëFile 8h CSV Logger</title>
<style>
  :root{
    --bg:#0f172a; --panel:#0b1220; --muted:#94a3b8; --text:#e5e7eb; --accent:#22d3ee; --good:#34d399; --warn:#f59e0b; --bad:#f87171;
  }
  html,body{height:100%}
  body{margin:0;background:radial-gradient(1200px 800px at 80% -10%, #1f2937 0, var(--bg) 40%);color:var(--text);font-family:ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial}
  .wrap{max-width:820px;margin:32px auto;padding:0 16px}
  h1{font-size:clamp(20px,3vw,30px);margin:0 0 10px}
  .panel{background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.15));border:1px solid rgba(255,255,255,.06);box-shadow:0 10px 30px rgba(0,0,0,.35);border-radius:16px;padding:16px}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:10px}
  button{appearance:none;border:1px solid rgba(255,255,255,.15);background:#111827;color:var(--text);border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer;transition:.2s}
  button:hover{transform:translateY(-1px);border-color:rgba(34,211,238,.5);box-shadow:0 8px 20px rgba(34,211,238,.15)}
  button:disabled{opacity:.5;cursor:not-allowed;box-shadow:none;transform:none}
  .status{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;color:var(--muted)}
  .stats{display:flex;gap:12px;flex-wrap:wrap}
  .stat{flex:1;min-width:200px;background:var(--panel);border:1px solid rgba(255,255,255,.06);border-radius:12px;padding:12px}
  .label{font-size:12px;letter-spacing:.05em;text-transform:uppercase;color:var(--muted)}
  .value{font-size:22px;font-weight:800}
  input[type=number]{width:80px;background:#111827;color:var(--text);border:1px solid rgba(255,255,255,.15);border-radius:8px;padding:8px 10px}
  a{color:var(--accent)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Polar H10 ‚Äî One‚ÄëFile CSV Logger</h1>
  <div class="panel">
    <div class="controls">
      <button id="connectBtn">üîó Connect H10</button>
      <button id="disconnectBtn" disabled>üîå Disconnect</button>
      <button id="startBtn" disabled>‚è∫Ô∏è Start Recording</button>
      <button id="stopBtn" disabled>‚èπÔ∏è Stop Recording</button>
      <label style="display:flex;align-items:center;gap:6px">
        <span>Flush every</span>
        <input id="flushSec" type="number" min="1" value="1" />
        <span>s</span>
      </label>
      <div class="status" id="status">Checking support‚Ä¶</div>
    </div>

    <div class="stats">
      <div class="stat"><div class="label">Frames</div><div class="value" id="framesVal">0</div></div>
      <div class="stat"><div class="label">Samples</div><div class="value" id="samplesVal">0</div></div>
      <div class="stat"><div class="label">Rate</div><div class="value" id="rateVal">0.0 Hz</div></div>
      <div class="stat"><div class="label">Recording</div><div class="value" id="recVal">No</div></div>
    </div>

    <p class="status" style="margin-top:10px">Requirements: Chrome/Edge ‚Ä¢ HTTPS or <code>http://localhost</code> ‚Ä¢ Keep the tab in the foreground and your machine awake for 8‚Äëhour sessions.</p>
  </div>
</div>

<script>
// ======== Polar H10 PMD UUIDs ========
const HR_SERVICE_UUID = 0x180D;
const HR_MEAS_UUID    = 0x2A37;
const PMD_SERVICE_UUID = 'fb005c80-02e7-f387-1cad-8acd2d8df0c8';
const PMD_CHAR1_UUID   = 'fb005c81-02e7-f387-1cad-8acd2d8df0c8'; // control
const PMD_CHAR2_UUID   = 'fb005c82-02e7-f387-1cad-8acd2d8df0c8'; // data

// Start ACC @ 200Hz, 8g, 16-bit (typical Polar command)
const ACC_WRITE = new Uint8Array([
  0x02, 0x02, 0x00, 0x01, // type=ACC(0x02), mode=stream(0x02)
  0xC8, 0x00,             // 0x00C8=200 Hz
  0x01, 0x01,             // range index, resolution
  0x10, 0x00,             // samples per frame (16)
  0x02, 0x01, 0x08, 0x00  // channels=xyz, 16-bit
]);

// ======== State ========
let device=null, server=null, dataChar=null, ctrlChar=null;
let rawFrames=0, totalSamples=0;
let lastCount=0, lastTime=0;
let uiTimer=null, rateTimer=null;
let wakeLock=null;

// Recording state
let recording=false;
let recHandle=null;        // FileSystemFileHandle
let recWriter=null;        // FileSystemWritableFileStream
let recBuffer='';
let recFlushEveryMs=1000;
let lastFlush=0;
let reopenTimer=null;      // periodic commit timer

// ======== UI ========
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');
const statusEl = document.getElementById('status');
const flushInput = document.getElementById('flushSec');
const framesVal = document.getElementById('framesVal');
const samplesVal = document.getElementById('samplesVal');
const rateVal = document.getElementById('rateVal');
const recVal = document.getElementById('recVal');

function setStatus(s){ statusEl.textContent = s; }
function setRec(val){ recVal.textContent = val ? 'Yes' : 'No'; }

// ======== Support check ========
(function init(){
  const isSecure = (window.isSecureContext || location.protocol==='https:' || location.hostname==='localhost');
  if (!('bluetooth' in navigator) || !isSecure){
    setStatus('Web Bluetooth requires Chrome/Edge in a secure context (HTTPS or http://localhost).');
    connectBtn.disabled = true; startBtn.disabled = true; stopBtn.disabled = true;
    return;
  }
  if (!('showSaveFilePicker' in window)){
    setStatus('Recording to one file needs Chrome/Edge.');
  } else {
    setStatus('Ready. Click Connect to find your Polar H10.');
  }
})();

// ======== BLE flow ========
async function connect(){
  try{
    setStatus('Requesting device‚Ä¶');
    device = await navigator.bluetooth.requestDevice({
      filters: [{name:'Polar H10'},{namePrefix:'Polar'}],
      optionalServices:[HR_SERVICE_UUID, PMD_SERVICE_UUID]
    });
    device.addEventListener('gattserverdisconnected', onDisconnected);

    setStatus('Connecting‚Ä¶');
    server = await device.gatt.connect();

    const pmdSvc = await server.getPrimaryService(PMD_SERVICE_UUID);
    ctrlChar = await pmdSvc.getCharacteristic(PMD_CHAR1_UUID);
    dataChar = await pmdSvc.getCharacteristic(PMD_CHAR2_UUID);

    setStatus('Starting accelerometer stream‚Ä¶');
    await ctrlChar.writeValueWithoutResponse(ACC_WRITE);
    await new Promise(r=>setTimeout(r,1000));
    await ctrlChar.writeValueWithoutResponse(ACC_WRITE); // belt + braces

    dataChar.addEventListener('characteristicvaluechanged', onPMD);
    await dataChar.startNotifications();

    // (Small HR read tickle improves reliability on some stacks)
    try{
      const hrSvc = await server.getPrimaryService(HR_SERVICE_UUID);
      const hrChar = await hrSvc.getCharacteristic(HR_MEAS_UUID);
      await hrChar.startNotifications();
      setTimeout(()=>{ hrChar.stopNotifications().catch(()=>{}); }, 1000);
    }catch{}

    connectBtn.disabled = true; disconnectBtn.disabled = false; startBtn.disabled = false;
    setStatus('Connected. Streaming ACC frames‚Ä¶');

    // UI rate update
    if (uiTimer) clearInterval(uiTimer);
    uiTimer = setInterval(()=>{
      framesVal.textContent = String(rawFrames);
      samplesVal.textContent = String(totalSamples);
    }, 250);

    if (rateTimer) clearInterval(rateTimer);
    rateTimer = setInterval(()=>{
      const now = performance.now();
      if (lastTime){
        const dt = (now - lastTime)/1000;
        const dN = totalSamples - lastCount;
        rateVal.textContent = (dN/dt).toFixed(1) + ' Hz';
      }
      lastTime = now; lastCount = totalSamples;
    }, 1000);

  }catch(err){
    console.error(err);
    setStatus('Connect error: ' + (err && err.message ? err.message : err));
  }
}

function onDisconnected(){
  setStatus('Disconnected');
  connectBtn.disabled = false; disconnectBtn.disabled = true; startBtn.disabled = true; stopBtn.disabled = true;
  try{ dataChar && dataChar.stopNotifications(); }catch{}
  if (uiTimer) clearInterval(uiTimer);
  if (rateTimer) clearInterval(rateTimer);
}

async function disconnect(){
  try{
    if (dataChar){ try{ await dataChar.stopNotifications(); }catch{} }
    if (device && device.gatt.connected) device.gatt.disconnect();
  }catch(e){ console.warn(e); }
}

// ======== PMD parsing ========
function parseAcc(dataView){
  const samples=[];
  if (dataView.byteLength < 10) return samples;
  const accuracy = dataView.getUint8(9);
  let sampleSize = (accuracy===0x00) ? 3 : 6; // 8-bit or 16-bit
  let offset = 10;
  for (let i=offset; i+sampleSize<=dataView.byteLength; i+=sampleSize){
    let x,y,z;
    if (sampleSize===3){ x=dataView.getInt8(i)/1000; y=dataView.getInt8(i+1)/1000; z=dataView.getInt8(i+2)/1000; }
    else { x=dataView.getInt16(i,true)/1000; y=dataView.getInt16(i+2,true)/1000; z=dataView.getInt16(i+4,true)/1000; }
    const m=Math.sqrt(x*x+y*y+z*z);
    samples.push({x,y,z,m});
  }
  return samples;
}

function parsePMD(dv){
  if (dv.byteLength < 9) return null;
  const frameType = dv.getUint8(0);
  const timestamp = dv.getBigUint64(1,true); // ns
  if (frameType===0x02 || frameType===0x00){
    const accSamples = parseAcc(dv);
    if (accSamples.length) return {timestamp, accSamples};
  }
  return null;
}

function onPMD(event){
  const dv = event.target.value;
  rawFrames++;
  const parsed = parsePMD(dv);
  if (!parsed) return;
  const tNow = Number(parsed.timestamp)/1e9; // seconds
  const n = parsed.accSamples.length;
  totalSamples += n;

  if (recording){
    // pre-size check: if buffer too large, flush early
    if (recBuffer.length > 900_000) flushRecording(true);
    for (let i=0;i<n;i++){
      const s = parsed.accSamples[i];
      const t = tNow - (n - i - 1)/200; // spread at 200 Hz
      recBuffer += `${t},${s.x},${s.y},${s.z},${s.m}\n`;
    }
    flushRecording();
  }
}

// ======== Recording helpers (single file) ========
async function acquireWakeLock(){
  try{ if ('wakeLock' in navigator){ wakeLock = await navigator.wakeLock.request('screen'); wakeLock.addEventListener('release', ()=>console.log('WakeLock released')); }}catch(e){ console.warn('wakeLock failed', e); }
}

async function openWriter(){
  // createWritable with keepExistingData, then seek to EOF
  recWriter = await recHandle.createWritable({ keepExistingData:true });
  const f = await recHandle.getFile();
  await recWriter.seek(f.size);
}

async function startRecording(){
  if (recording) return;
  if (!server || !dataChar){ alert('Connect to the H10 first.'); return; }
  if (!('showSaveFilePicker' in window)){ alert('Use Chrome/Edge over HTTPS (or http://localhost) for single-file recording.'); return; }
  try{
    recFlushEveryMs = Math.max(1, Number(flushInput.value||1))*1000;
    recHandle = await window.showSaveFilePicker({
      suggestedName: `polar_h10_acc_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`,
      types:[{description:'CSV', accept:{'text/csv':['.csv']}}]
    });
    await openWriter();

    // If this is a brand-new file (size 0), write header
    const existing = await recHandle.getFile();
    if (existing.size === 0){ await recWriter.write('timestamp,x,y,z,magnitude\n'); }

    await acquireWakeLock();
    recording = true;
    startBtn.disabled = true; stopBtn.disabled = false; setRec(true);
    lastFlush = performance.now();
    setStatus('Recording‚Ä¶ writing CSV batches to a single file');

    // periodic commit: every 10 min ensure bytes are on disk
    reopenTimer = setInterval(commitAndReopen, 10*60*1000);
  }catch(err){
    console.error('startRecording', err);
    setStatus('Recording not started: ' + err.message);
  }
}

async function flushRecording(force=false){
  const now = performance.now();
  if (!recording || !recWriter) return;
  if (!force && (now - lastFlush < recFlushEveryMs) && recBuffer.length < 1_000_000) return;
  lastFlush = now;
  if (recBuffer.length){ await recWriter.write(recBuffer); recBuffer=''; }
}

async function commitAndReopen(){
  try{
    await flushRecording(true);
    if (recWriter){ await recWriter.close(); }
    await openWriter();
  }catch(e){ console.error('commit cycle', e); }
}

async function stopRecording(){
  if (!recording) return;
  try{
    clearInterval(reopenTimer); reopenTimer=null;
    await flushRecording(true);
    if (recWriter){ await recWriter.close(); recWriter=null; }
    if (wakeLock){ try{ await wakeLock.release(); }catch{} wakeLock=null; }
    recording=false; setRec(false);
    startBtn.disabled = false; stopBtn.disabled = true;
    setStatus('Recording stopped. File closed.');
  }catch(err){
    console.error('stopRecording', err);
    setStatus('Error stopping recording: ' + err.message);
  }
}

// Warn on tab close while recording
window.addEventListener('beforeunload', (e)=>{
  if (recording){ e.preventDefault(); e.returnValue=''; }
});

// ======== Wire up ========
connectBtn.addEventListener('click', connect);
disconnectBtn.addEventListener('click', disconnect);
startBtn.addEventListener('click', startRecording);
stopBtn.addEventListener('click', stopRecording);

</script>
</body>
</html>
