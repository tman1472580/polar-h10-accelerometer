<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Polar H10 ‚Üí Accelerometer Logger + 3D Motion</title>
  <style>
    :root {
      --bg: #0f172a;       /* slate-900 */
      --panel: #111827;    /* gray-900 */
      --muted: #94a3b8;    /* slate-400 */
      --text: #e5e7eb;     /* gray-200 */
      --accent: #22d3ee;   /* cyan-400 */
      --good: #34d399;     /* emerald-400 */
      --fair: #f59e0b;     /* amber-500 */
      --poor: #f87171;     /* red-400 */
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 80% -10%, #1f2937 0, var(--bg) 40%);
      color: var(--text);
    }
    .wrap { max-width: 1200px; margin: 32px auto; padding: 0 16px; }
    header { display:flex; align-items:center; gap:16px; margin-bottom: 16px; }
    h1 { font-size: clamp(22px, 3vw, 32px); line-height: 1.1; margin: 0; }
    .tag { padding: 4px 10px; border-radius: 999px; background: #0ea5e9; color:#002233; font-weight:700; font-size:12px; letter-spacing: .04em; }

    .panel { background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.15)); border: 1px solid rgba(255,255,255,.06); box-shadow: 0 10px 30px rgba(0,0,0,.35); border-radius: 16px; padding: 16px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 1100px){ .grid{ grid-template-columns: 1.1fr .9fr; } }

    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    button{ appearance:none; border:1px solid rgba(255,255,255,.15); background: #111827; color: var(--text); border-radius: 12px; padding: 10px 14px; font-weight: 600; cursor: pointer; transition: .2s; }
    button:hover{ transform: translateY(-1px); border-color: rgba(34,211,238,.5); box-shadow: 0 8px 20px rgba(34,211,238,.15); }
    button:disabled{ opacity:.5; cursor:not-allowed; box-shadow:none; transform:none; }
    .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: var(--muted); }

    .statbox { display:flex; gap:20px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .stat { background: #0b1220; border: 1px solid rgba(255,255,255,.06); border-radius: 14px; padding: 14px 16px; flex:1; min-width: 220px; }
    .label { color: var(--muted); font-size: 12px; letter-spacing:.05em; text-transform: uppercase; }
    .value { font-size: 32px; font-weight: 800; }
    .value small{ font-size: 14px; font-weight: 600; color: var(--muted); }

    canvas.chart { width: 100%; height: 220px; background: #0b1220; border:1px solid rgba(255,255,255,.06); border-radius: 12px; }

    /* 3D container */
    #threeWrap { height: 520px; background:#0b1220; border:1px solid rgba(255,255,255,.06); border-radius:12px; position:relative; overflow:hidden; }
    #threeCanvas { width: 100%; height: 100%; display:block; }
    #hud {
      position:absolute; left:12px; top:8px; font:12px ui-monospace, monospace; color:#cbd5e1; background:rgba(2,6,23,.6);
      border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:8px 10px;
    }

    footer { margin-top: 24px; color: var(--muted); font-size: 12px; }
    a { color: var(--accent); }
    .tiny { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="tag">Web Bluetooth</div>
    <h1>Polar H10 ‚Üí Accelerometer Logger + 3D Motion</h1>
  </header>

  <div class="panel">
    <div class="controls">
      <button id="connectBtn">üîó Connect H10</button>
      <button id="disconnectBtn" disabled>üîå Disconnect H10</button>
      <button id="saveAccBtn">üíæ Save ACC CSV</button>
      <button id="debugBtn">üêõ Debug Info</button>
      <button id="retryBtn" disabled>üîÑ Retry Activation</button>
      <button id="resetMotionBtn" disabled>üéØ Reset Motion Start</button>
      <button id="recenterBtn" disabled>üìç Set Current as Center</button>
      <div class="status" id="status">Idle</div>
    </div>

    <div class="statbox" style="margin-top:12px">
      <div class="stat">
        <div class="label">Acceleration</div>
        <div class="value" id="accVal">‚Äî <small>g</small></div>
      </div>
      <div class="stat">
        <div class="label">Motion Distance (XY)</div>
        <div class="value" id="motionDistVal">0.00 <small>m</small></div>
      </div>
      <div class="stat">
        <div class="label">3D Displacement</div>
        <div class="value" id="disp3dVal">0.00 <small>m</small></div>
      </div>
    </div>

    <div class="grid" style="margin-top: 8px">
      <div>
        <div class="label">Accelerometry (X axis)</div>
        <canvas id="accxCanvas" class="chart" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (Y axis)</div>
        <canvas id="accyCanvas" class="chart" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (Z axis)</div>
        <canvas id="acczCanvas" class="chart" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (magnitude)</div>
        <canvas id="accmCanvas" class="chart" width="640" height="220"></canvas>
      </div>

      <div style="grid-column: 1 / -1;">
        <div class="label">Live 3D Motion (relative to central reference)</div>
        <div id="threeWrap">
          <canvas id="threeCanvas"></canvas>
          <div id="hud">
            <div><b>Controls:</b> Left-drag = orbit, Right-drag = pan, Wheel = zoom</div>
            <div id="hudInfo" class="tiny"></div>
          </div>
        </div>
        <div class="tiny" style="color:var(--muted); margin-top:6px;">
          Motion is estimated by subtracting a ~1s gravity/bias baseline (on reset/connect), then integrating acceleration. Expect drift over time.
        </div>
      </div>
    </div>

    <div class="statbox" style="margin-top:12px">
      <div class="stat">
        <div class="label">Data Points</div>
        <div class="value" id="dataCountVal">0 <small>samples</small></div>
      </div>
      <div class="stat">
        <div class="label">Collection Time</div>
        <div class="value" id="collectionTimeVal">0 <small>minutes</small></div>
      </div>
      <div class="stat">
        <div class="label">Data Rate</div>
        <div class="value" id="dataRateVal">0 <small>Hz</small></div>
      </div>
    </div>

    <footer>
      <p>Notes: Use <strong>Chrome</strong> (or Edge) in a <strong>secure context</strong> (HTTPS or <code>http://localhost</code>). Ensure strap contact; close Polar Beat/Flow so they don‚Äôt ‚Äústeal‚Äù the H10.</p>
    </footer>
  </div>
</div>

<!-- Three.js -->
<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>

<script>
// ================== Config & UUIDs ==================
const HR_SERVICE_UUID = 0x180D;
const HR_MEAS_UUID    = 0x2A37;

// ‚úÖ Correct Polar PMD UUIDs
const PMD_SERVICE_UUID = 'fb005c80-02e7-f387-1cad-8acd2d8df0c8';
const PMD_CHAR1_UUID   = 'fb005c81-02e7-f387-1cad-8acd2d8df0c8'; // control
const PMD_CHAR2_UUID   = 'fb005c82-02e7-f387-1cad-8acd2d8df0c8'; // data

// Polar sample commands
const ECG_WRITE = new Uint8Array([0x02,0x00,0x00,0x01, 0x82,0x00,0x01,0x01, 0x0E,0x00]);
const ACC_WRITE = new Uint8Array([0x02,0x02,0x00,0x01, 0xC8,0x00,0x01,0x01, 0x10,0x00, 0x02,0x01,0x08,0x00]); // 200Hz, ¬±8g (typ)

// General
let WINDOW_SEC = 36000;           // 10h ring buffer
const G = 9.80665;                // m/s¬≤ per 1 g
const TARGET_FS = 200;            // assumed rate
const CONNECT_TIMEOUT_MS = 20000; // longer timeout

// ================== State ==================
let device=null, server=null, dataChar=null;
let accBuffer=[]; // [{t,x,y,z,m}]
let startTime=null, lastDataCount=0, lastDataTime=0, rawDataCount=0;
let updateTimer=null, uiTimer=null;

// Motion baseline/integration
const BASELINE_SEC = 1.0;
const BASELINE_COUNT = Math.round(BASELINE_SEC * TARGET_FS);
let baselineCollecting=false, baselineReady=false, baselineSamples=[];
let baselineAcc={x:0,y:0,z:0};  // g
let vel={x:0,y:0,z:0};          // m/s
let pos={x:0,y:0,z:0};          // m
let lastSampleTime=null;
const VEL_DAMP_PER_SAMPLE = 0.985; // drift taming

// Central reference (visual)
let originOffset={x:0,y:0,z:0};

// ================== UI Elements ==================
const $ = sel => document.querySelector(sel);
const connectBtn = $('#connectBtn');
const disconnectBtn = $('#disconnectBtn');
const saveAccBtn = $('#saveAccBtn');
const debugBtn = $('#debugBtn');
const retryBtn = $('#retryBtn');
const resetMotionBtn = $('#resetMotionBtn');
const recenterBtn = $('#recenterBtn');
const statusEl = $('#status');
const accVal = $('#accVal');
const dataCountVal = $('#dataCountVal');
const collectionTimeVal = $('#collectionTimeVal');
const dataRateVal = $('#dataRateVal');
const motionDistVal = $('#motionDistVal');
const disp3dVal = $('#disp3dVal');

const accxctx = $('#accxCanvas').getContext('2d');
const accyctx = $('#accyCanvas').getContext('2d');
const acczctx = $('#acczCanvas').getContext('2d');
const accmctx = $('#accmCanvas').getContext('2d');

function setStatus(msg){ statusEl.textContent = msg; }

// ================== GATT op serialization ==================
let gattLock = Promise.resolve();
function withGattLock(fn){
  gattLock = gattLock.then(fn, fn);
  return gattLock;
}

// ================== Helpers ==================
function resetMotion(){
  baselineCollecting = true;
  baselineReady = false;
  baselineSamples = [];
  baselineAcc = {x:0,y:0,z:0};
  vel = {x:0,y:0,z:0};
  pos = {x:0,y:0,z:0};
  lastSampleTime = null;
  originOffset = {x:0,y:0,z:0}; // central reference at start
  resetThreePath();
  setStatus('Motion reset. Hold steady ~1s to capture baseline‚Ä¶');
}

function setCurrentAsCenter(){
  originOffset = {x:pos.x, y:pos.y, z:pos.z};
  setStatus('Visualization recentered on current position.');
}

function addToBaseline(sampleG){
  baselineSamples.push({x:sampleG.x, y:sampleG.y, z:sampleG.z});
  if (baselineSamples.length >= BASELINE_COUNT){
    const sum = baselineSamples.reduce((a,s)=>({x:a.x+s.x, y:a.y+s.y, z:a.z+s.z}), {x:0,y:0,z:0});
    baselineAcc = {
      x: sum.x / baselineSamples.length,
      y: sum.y / baselineSamples.length,
      z: sum.z / baselineSamples.length
    };
    baselineCollecting = false;
    baselineReady = true;
    setStatus('Baseline captured. Tracking from central reference.');
  }
}

function processMotionSample(sampleG, t){
  if (baselineCollecting){ addToBaseline(sampleG); return; }
  if (!baselineReady) return;

  if (lastSampleTime == null){ lastSampleTime = t; return; }
  let dt = t - lastSampleTime;
  if (dt <= 0 || dt > 0.2) dt = 1 / TARGET_FS;
  lastSampleTime = t;

  // subtract baseline (g) and convert
  const ax = (sampleG.x - baselineAcc.x) * G;
  const ay = (sampleG.y - baselineAcc.y) * G;
  const az = (sampleG.z - baselineAcc.z) * G;

  vel.x = (vel.x + ax*dt) * VEL_DAMP_PER_SAMPLE;
  vel.y = (vel.y + ay*dt) * VEL_DAMP_PER_SAMPLE;
  vel.z = (vel.z + az*dt) * VEL_DAMP_PER_SAMPLE;

  pos.x += vel.x * dt;
  pos.y += vel.y * dt;
  pos.z += vel.z * dt;

  pushThreePoint(pos.x - originOffset.x, pos.y - originOffset.y, pos.z - originOffset.z);
}

function keepWindow(){
  while (accBuffer.length && accBuffer[0].t < accBuffer[accBuffer.length-1].t - WINDOW_SEC){ accBuffer.shift(); }
}

function saveAccelerometerData(){
  if (!accBuffer.length){ alert('No accelerometer data to save'); return; }
  let csv = 'timestamp,x,y,z,magnitude\n';
  for (const s of accBuffer) csv += `${s.t},${s.x},${s.y},${s.z},${s.m}\n`;
  const blob = new Blob([csv], { type:'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href=url; a.download=`accelerometer_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
  document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url);
  setStatus(`Saved ${accBuffer.length} samples to CSV`);
}

function showDebugInfo(){
  console.log('=== DEBUG ===');
  console.log('Device connected?', !!device);
  console.log('Server connected?', !!server);
  console.log('dataChar?', !!dataChar);
  console.log('Raw frames:', rawDataCount);
  console.log('ACC buffer:', accBuffer.length);
  console.log('Baseline ready:', baselineReady, 'collecting:', baselineCollecting);
  console.log('Baseline (g):', baselineAcc);
  console.log('Velocity (m/s):', vel);
  console.log('Position (m):', pos);
  alert('Debug info printed to console.');
}

// ================== Tiny plotting for 2D ==================
function drawSeries(ctx, data){
  const w=ctx.canvas.width, h=ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.save(); ctx.translate(60,10);
  const iw=w-70, ih=h-50;
  ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.lineWidth=1;
  for (let i=0;i<5;i++){ const y=10+i*(ih/4); ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(iw,y); ctx.stroke(); }
  for (let i=0;i<5;i++){ const x=i*(iw/4); ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,ih+10); ctx.stroke(); }
  if (!data || data.x.length<2){ ctx.restore(); return; }
  const xs=data.x, ys=data.y;
  const xmin=Math.min(...xs), xmax=Math.max(...xs);
  const ymin=Math.min(...ys), ymax=Math.max(...ys);
  const sx=v=>(v-xmin)/(xmax-xmin+1e-9)*iw;
  const sy=v=>ih-(v-ymin)/(ymax-ymin+1e-9)*ih;
  ctx.strokeStyle='rgba(34,211,238,0.9)'; ctx.lineWidth=2;
  ctx.beginPath(); ctx.moveTo(sx(xs[0]), sy(ys[0]));
  for (let i=1;i<xs.length;i++) ctx.lineTo(sx(xs[i]), sy(ys[i]));
  ctx.stroke();
  ctx.restore();
}

function updateUI(){
  // Acc magnitude
  if (accBuffer.length){
    accVal.innerHTML = accBuffer[accBuffer.length-1].m.toFixed(2) + ' <small>g</small>';
  } else accVal.innerHTML = '‚Äî <small>g</small>';

  // Distances from central ref (visual)
  const vx = pos.x - originOffset.x, vy = pos.y - originOffset.y, vz = pos.z - originOffset.z;
  motionDistVal.innerHTML = Math.hypot(vx,vy).toFixed(2) + ' <small>m</small>';
  disp3dVal.innerHTML = Math.hypot(vx,vy,vz).toFixed(2) + ' <small>m</small>';

  // Counters
  dataCountVal.innerHTML = accBuffer.length + ' <small>samples</small>';
  if (startTime){
    const minutes = Math.floor(((Date.now()/1000)-startTime)/60);
    collectionTimeVal.innerHTML = minutes + ' <small>minutes</small>';
  } else collectionTimeVal.innerHTML = '0 <small>minutes</small>';

  const now = Date.now()/1000;
  if (lastDataTime>0 && now>lastDataTime){
    const hz = (accBuffer.length - lastDataCount) / (now - lastDataTime);
    dataRateVal.innerHTML = hz.toFixed(1) + ' <small>Hz</small>';
  } else dataRateVal.innerHTML = '0.0 <small>Hz</small>';
  lastDataCount = accBuffer.length; lastDataTime = now;

  // 2D plots
  if (accBuffer.length>=2){
    const t = accBuffer.map(p=>p.t);
    drawSeries(accxctx, {x:t, y:accBuffer.map(p=>p.x)});
    drawSeries(accyctx, {x:t, y:accBuffer.map(p=>p.y)});
    drawSeries(acczctx, {x:t, y:accBuffer.map(p=>p.z)});
    drawSeries(accmctx, {x:t, y:accBuffer.map(p=>p.m)});
  } else {
    drawSeries(accxctx,{x:[],y:[]}); drawSeries(accyctx,{x:[],y:[]});
    drawSeries(acczctx,{x:[],y:[]}); drawSeries(accmctx,{x:[],y:[]});
  }

  // HUD
  $('#hudInfo').textContent =
    `baseline: ${baselineReady ? 'ready' : (baselineCollecting ? 'collecting‚Ä¶' : '‚Äî')} | ` +
    `pos: (${pos.x.toFixed(2)}, ${pos.y.toFixed(2)}, ${pos.z.toFixed(2)}) m | points: ${threeLineCount()}`;
}

// ================== BLE parsing ==================
function parseAcc(dataView){
  const samples=[];
  if (dataView.byteLength<10) return samples;
  const accuracy = dataView.getUint8(9);
  const size = (accuracy===0x00) ? 3 : 6;
  const off = 10;
  for (let i=off; i+size-1<dataView.byteLength; i+=size){
    let x,y,z;
    if (size===3){
      x=dataView.getInt8(i)/1000; y=dataView.getInt8(i+1)/1000; z=dataView.getInt8(i+2)/1000;
    } else {
      x=dataView.getInt16(i,true)/1000; y=dataView.getInt16(i+2,true)/1000; z=dataView.getInt16(i+4,true)/1000;
    }
    samples.push({x,y,z,m:Math.hypot(x,y,z)});
  }
  return samples;
}

function parsePMD(dv){
  if (dv.byteLength<9) return null;
  const ft = dv.getUint8(0);
  const ts = dv.getBigUint64(1,true);
  if (ft===0x02 || ft===0x00){
    const accSamples = parseAcc(dv);
    if (accSamples.length) return {timestamp:ts, accSamples};
  }
  return null;
}

// ================== BLE Flow ==================
async function gattConnectWithTimeout(dev){
  const connectPromise = dev.gatt.connect();
  const timeout = new Promise((_,rej)=>setTimeout(()=>rej(new Error('Connection timeout')), CONNECT_TIMEOUT_MS));
  return Promise.race([connectPromise, timeout]);
}

async function connect(){
  setStatus('Requesting device‚Ä¶');
  // Less picky: show picker for all, but request PMD service access
  device = await navigator.bluetooth.requestDevice({
    acceptAllDevices: true,
    optionalServices: [HR_SERVICE_UUID, PMD_SERVICE_UUID]
  });
  device.addEventListener('gattserverdisconnected', onDisconnected);

  // Retry a few times
  let attempt=0, max=3;
  while (attempt<max){
    try{
      setStatus(`Connecting‚Ä¶ (try ${attempt+1}/${max})`);
      server = await gattConnectWithTimeout(device);
      break;
    }catch(e){
      attempt++;
      if (attempt>=max) throw e;
      await new Promise(r=>setTimeout(r,1500));
    }
  }

  setStatus('Getting services‚Ä¶');

  // (best-effort) Device info/HR jiggle to wake device
  try { await server.getPrimaryService('0000180a-0000-1000-8000-00805f9b34fb'); } catch {}
  try {
    const hrSvc = await server.getPrimaryService(HR_SERVICE_UUID);
    const hrChar = await hrSvc.getCharacteristic(HR_MEAS_UUID);
    try { await withGattLock(()=>hrChar.startNotifications()); setTimeout(()=>{ try{ hrChar.stopNotifications(); }catch{} }, 1000); } catch {}
  } catch {}

  // PMD control + data
  const pmdSvc = await server.getPrimaryService(PMD_SERVICE_UUID);
  const ctrlChar = await pmdSvc.getCharacteristic(PMD_CHAR1_UUID);
  dataChar = await pmdSvc.getCharacteristic(PMD_CHAR2_UUID);

  // Start ACC stream (write twice with a gap helps some stacks)
  await withGattLock(()=>ctrlChar.writeValueWithoutResponse(ACC_WRITE));
  await new Promise(r=>setTimeout(r,900));
  await withGattLock(()=>ctrlChar.writeValueWithoutResponse(ACC_WRITE));

  dataChar.addEventListener('characteristicvaluechanged', onPMD);
  await withGattLock(()=>dataChar.startNotifications());

  setStatus('Connected. Streaming accelerometer data‚Ä¶');
  connectBtn.disabled = true;
  disconnectBtn.disabled = false;
  retryBtn.disabled = false;
  resetMotionBtn.disabled = false;
  recenterBtn.disabled = false;

  startTime = Date.now()/1000;

  // Start loops
  if (updateTimer) clearInterval(updateTimer);
  if (uiTimer) clearInterval(uiTimer);
  updateTimer = setInterval(keepWindow, 1000);
  uiTimer = setInterval(()=>{ updateUI(); renderThree(); }, 100);

  // Auto baseline + center
  resetMotion();

  // If no frames show up quickly, try an alternate command
  setTimeout(async ()=>{
    if (rawDataCount===0){
      setStatus('Connected but no data yet. Trying alternative activation‚Ä¶');
      const alt = new Uint8Array([0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00]);
      try { await withGattLock(()=>ctrlChar.writeValueWithoutResponse(alt)); } catch {}
    }
  }, 4000);
}

function onPMD(event){
  const dv = event.target.value;
  rawDataCount++;
  const parsed = parsePMD(dv);
  if (!parsed) return;
  const tNow = Number(parsed.timestamp)/1e9;
  const n = parsed.accSamples.length;
  for (let i=0;i<n;i++){
    const s = parsed.accSamples[i];
    const t = tNow - (n - i - 1) / TARGET_FS; // even spread
    accBuffer.push({t, x:s.x, y:s.y, z:s.z, m:s.m});
    processMotionSample(s, t);
  }
}

function onDisconnected(){
  setStatus('Disconnected');
  connectBtn.disabled = false;
  disconnectBtn.disabled = true;
  retryBtn.disabled = true;
  resetMotionBtn.disabled = true;
  recenterBtn.disabled = true;
  if (dataChar){ try{ dataChar.stopNotifications(); } catch{} }
  if (updateTimer) clearInterval(updateTimer);
  if (uiTimer) clearInterval(uiTimer);
}

async function disconnect(){
  try{
    if (dataChar){ try{ await dataChar.stopNotifications(); } catch{} }
    if (device?.gatt?.connected) device.gatt.disconnect();
  }catch(e){ console.error(e); }
}

// Retry ‚Äúactivation‚Äù without reconnecting
retryBtn.addEventListener('click', async ()=>{
  try{
    if (!server) return;
    const pmdSvc = await server.getPrimaryService(PMD_SERVICE_UUID);
    const ctrlChar = await pmdSvc.getCharacteristic(PMD_CHAR1_UUID);
    await withGattLock(()=>ctrlChar.writeValueWithoutResponse(ACC_WRITE));
    setStatus('Retry command sent.');
  }catch(e){ setStatus('Retry failed: '+e.message); }
});

// ================== Events ==================
connectBtn.addEventListener('click', connectWithRetry);
disconnectBtn.addEventListener('click', disconnect);
saveAccBtn.addEventListener('click', saveAccelerometerData);
debugBtn.addEventListener('click', showDebugInfo);
resetMotionBtn.addEventListener('click', resetMotion);
recenterBtn.addEventListener('click', setCurrentAsCenter);

// Feature detection
if (!('bluetooth' in navigator)){
  setStatus('Web Bluetooth not available. Try Chrome/Edge.');
  connectBtn.disabled = true;
} else {
  const isMac = navigator.platform.toUpperCase().includes('MAC');
  setStatus(isMac ? 'Ready. On macOS, ensure Bluetooth is enabled and H10 is paired.' : 'Ready. Make sure Bluetooth is on and H10 is nearby.');
}

// Connect with retries wrapper
let connectionRetries = 0;
const maxRetries = 3;
async function connectWithRetry(){
  try{
    await connect();
    connectionRetries = 0;
  }catch(e){
    connectionRetries++;
    if (connectionRetries < maxRetries){
      setStatus(`Connection failed. Retrying‚Ä¶ (${connectionRetries}/${maxRetries})`);
      setTimeout(connectWithRetry, 1800);
    } else {
      setStatus('Connection failed repeatedly. Check battery/contact/nearby apps and try again.');
      connectionRetries = 0;
    }
  }
}

// ================== Three.js 3D ==================
let renderer, scene, camera, controls;
let lineGeom, lineMesh, linePoints=[];
let headMesh, originMesh, axesHelper, grid;
const threeCanvas = document.getElementById('threeCanvas');

function initThree(){
  renderer = new THREE.WebGLRenderer({ canvas: threeCanvas, antialias:true });
  resizeThree();
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  camera = new THREE.PerspectiveCamera(55, threeCanvas.clientWidth/threeCanvas.clientHeight, 0.01, 1000);
  camera.position.set(2.5, 2.0, 3.0);

  controls = new THREE.OrbitControls(camera, threeCanvas);
  controls.enableDamping = true;

  // Lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(3,5,2); scene.add(dir);

  // Grid & axes
  grid = new THREE.GridHelper(10, 20, 0x57708a, 0x233044); // 10 m extent
  // GridHelper is XZ plane by default (good as "floor"). Keep as is.
  scene.add(grid);

  axesHelper = new THREE.AxesHelper(1.5); // 1.5 m
  scene.add(axesHelper);

  // Path
  lineGeom = new THREE.BufferGeometry();
  const lineMat = new THREE.LineBasicMaterial({ color: 0x22d3ee });
  lineMesh = new THREE.Line(lineGeom, lineMat);
  scene.add(lineMesh);

  // Central reference marker
  const originGeo = new THREE.SphereGeometry(0.04, 24, 24);
  const originMat = new THREE.MeshStandardMaterial({ color: 0x22c55e });
  originMesh = new THREE.Mesh(originGeo, originMat);
  originMesh.position.set(0,0,0);
  scene.add(originMesh);

  // Head/current position
  const headGeo = new THREE.SphereGeometry(0.05, 24, 24);
  const headMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive:0x332200, emissiveIntensity:0.3 });
  headMesh = new THREE.Mesh(headGeo, headMat);
  scene.add(headMesh);

  window.addEventListener('resize', resizeThree);
  resetThreePath();
  renderThree();
}

function resizeThree(){
  const w = threeCanvas.clientWidth || threeCanvas.parentElement.clientWidth;
  const h = threeCanvas.clientHeight || threeCanvas.parentElement.clientHeight;
  renderer?.setSize(w, h, false);
  if (camera){ camera.aspect = w/h; camera.updateProjectionMatrix(); }
}

function resetThreePath(){
  linePoints = [new THREE.Vector3(0,0,0)];
  lineGeom.setFromPoints(linePoints);
  headMesh && headMesh.position.set(0,0,0);
}

function pushThreePoint(x,y,z){
  // If you prefer a different up-axis mapping, swap here.
  const p = new THREE.Vector3(x, y, z);
  linePoints.push(p);
  if (linePoints.length > 60000) linePoints.shift();
  lineGeom.setFromPoints(linePoints);
  if (headMesh) headMesh.position.copy(p);
}

function threeLineCount(){ return linePoints.length; }

function renderThree(){
  controls.update();
  renderer.render(scene, camera);
}

// Kick off 3D
initThree();
</script>
</body>
</html>
