<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Polar H10 ‚Üí Accelerometer Data Logger (Web Bluetooth, 3D Motion)</title>
  <style>
    :root {
      --bg: #0f172a;
      --panel: #111827;
      --muted: #94a3b8;
      --text: #e5e7eb;
      --accent: #22d3ee;
      --good: #34d399;
      --fair: #f59e0b;
      --poor: #f87171;
    }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, Noto Sans, "Apple Color Emoji", "Segoe UI Emoji";
      background: radial-gradient(1200px 800px at 80% -10%, #1f2937 0, var(--bg) 40%);
      color: var(--text);
    }
    .wrap { max-width: 980px; margin: 32px auto; padding: 0 16px; }
    header { display:flex; align-items:center; gap:16px; margin-bottom: 16px; }
    h1 { font-size: clamp(22px, 3vw, 32px); line-height: 1.1; margin: 0; }
    .tag { padding: 4px 10px; border-radius: 999px; background: #0ea5e9; color:#002233; font-weight:700; font-size:12px; letter-spacing: .04em; }

    .panel { background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.15)); border: 1px solid rgba(255,255,255,.06); box-shadow: 0 10px 30px rgba(0,0,0,.35); border-radius: 16px; padding: 16px; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 16px; }
    @media (min-width: 900px){ .grid{ grid-template-columns: 1.1fr .9fr; } }

    .controls{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; }
    button{ appearance:none; border:1px solid rgba(255,255,255,.15); background: #111827; color: var(--text); border-radius: 12px; padding: 10px 14px; font-weight: 600; cursor: pointer; transition: .2s; }
    button:hover{ transform: translateY(-1px); border-color: rgba(34,211,238,.5); box-shadow: 0 8px 20px rgba(34,211,238,.15); }
    button:disabled{ opacity:.5; cursor:not-allowed; box-shadow:none; transform:none; }
    .status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: var(--muted); }

    .statbox { display:flex; gap:20px; align-items: center; justify-content: space-between; }
    .stat { background: #0b1220; border: 1px solid rgba(255,255,255,.06); border-radius: 14px; padding: 14px 16px; flex:1; }
    .label { color: var(--muted); font-size: 12px; letter-spacing:.05em; text-transform: uppercase; }
    .value { font-size: 32px; font-weight: 800; }
    .value small{ font-size: 14px; font-weight: 600; color: var(--muted); }
    .good { color: var(--good); }
    .fair { color: var(--fair); }
    .poor { color: var(--poor); }

    canvas { width: 100%; height: 220px; background: #0b1220; border:1px solid rgba(255,255,255,.06); border-radius: 12px; }
    /* taller for the 3D container */
    #motion3DContainer { height: 360px; background: #0b1220; border:1px solid rgba(255,255,255,.06); border-radius: 12px; position: relative; overflow: hidden; }
    #motion3DContainer .overlay {
      position:absolute; left:10px; bottom:10px; font: 12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color: rgba(148,163,184,.9);
      pointer-events: none;
    }
    footer { margin-top: 24px; color: var(--muted); font-size: 12px; }
    a { color: var(--accent); }
    .tiny { font-size: 12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
  </style>
  <!-- Three.js (global THREE namespace) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<div class="wrap">
  <header>
    <div class="tag">Web Bluetooth</div>
    <h1>Polar H10 ‚Üí Accelerometer Data Logger</h1>
  </header>

  <div class="panel">
    <div class="controls">
      <button id="connectBtn">üîó Connect H10</button>
      <button id="disconnectBtn" disabled>üîå Disconnect H10</button>
      <button id="saveAccBtn">üíæ Save Accelerometer Data (CSV)</button>
      <button id="debugBtn">üêõ Debug Info</button>
      <button id="retryBtn" disabled>üîÑ Retry Activation</button>
      <button id="resetMotionBtn" disabled>üéØ Reset Motion Start</button>
      <div class="status" id="status">Idle</div>
    </div>

    <div class="statbox" style="margin-top:12px">
      <div class="stat">
        <div class="label">Acceleration</div>
        <div class="value" id="accVal">‚Äî <small>g</small></div>
      </div>
      <div class="stat">
        <div class="label">Motion Distance (3D)</div>
        <div class="value" id="motionDistVal">0.00 <small>m</small></div>
      </div>
    </div>

    <div class="grid" style="margin-top: 8px">
      <div>
        <div class="label">Accelerometry (X axis)</div>
        <canvas id="accxCanvas" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (Y axis)</div>
        <canvas id="accyCanvas" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (Z axis)</div>
        <canvas id="acczCanvas" width="640" height="220"></canvas>
      </div>
      <div>
        <div class="label">Accelerometry (magnitude)</div>
        <canvas id="accmCanvas" width="640" height="220"></canvas>
      </div>

      <!-- 3D Motion Viewer -->
      <div style="grid-column: 1 / -1;">
        <div class="label">Live Motion (3D) ‚Äî starts at (0,0,0) on reset</div>
        <div id="motion3DContainer">
          <div class="overlay">Drag to orbit ‚Ä¢ Scroll to zoom ‚Ä¢ Double-click to reset view</div>
        </div>
        <div class="tiny" style="color:var(--muted); margin-top:6px;">
          Motion is estimated by subtracting a 1-second baseline (gravity/bias) after you click <em>Reset Motion Start</em>, then integrating acceleration in 3D. Expect drift over time.
        </div>
      </div>
    </div>

    <div class="statbox" style="margin-top:12px">
      <div class="stat">
        <div class="label">Data Points</div>
        <div class="value" id="dataCountVal">0 <small>samples</small></div>
      </div>
      <div class="stat">
        <div class="label">Collection Time</div>
        <div class="value" id="collectionTimeVal">0 <small>minutes</small></div>
      </div>
      <div class="stat">
        <div class="label">Data Rate</div>
        <div class="value" id="dataRateVal">0 <small>Hz</small></div>
      </div>
    </div>

    <footer>
      <p>Notes: Use <strong>Chrome</strong> or another browser that supports Web Bluetooth in a <strong>secure context</strong> (HTTPS or <code>http://localhost</code>). Wear and moisten the strap so it transmits. Data is collected for up to 10 hours and can be exported as CSV.</p>
    </footer>
  </div>
</div>

<script>
// ================== Config ==================
const HR_SERVICE_UUID = 0x180D;
const HR_MEAS_UUID    = 0x2A37;

const PMD_SERVICE_UUID = 'fb005c80-02e7-f387-1cad-8acd2d8df0c8';
const PMD_CHAR1_UUID = 'fb005c81-02e7-f387-1cad-8acd2d8df0c8';
const PMD_CHAR2_UUID = 'fb005c82-02e7-f387-1cad-8acd2d8df0c8';

const ECG_WRITE = new Uint8Array([
  0x02, 0x00, 0x00, 0x01,
  0x82, 0x00, 0x01, 0x01,
  0x0E, 0x00
]);

const ACC_WRITE = new Uint8Array([
  0x02, 0x02, 0x00, 0x01,
  0xC8, 0x00, 0x01, 0x01,
  0x10, 0x00, 0x02, 0x01,
  0x08, 0x00
]);

let WINDOW_SEC = 36000;   // 10 hours in seconds

// ================== State ==================
let device = null;
let server = null;
let dataChar = null;
let accBuffer = []; // [{t: epochSeconds, x: g, y: g, z: g, m: g}]
let startTime = null;
let lastDataCount = 0;
let lastDataTime = 0;
let rawDataCount = 0;

let updateTimer = null;
let uiTimer = null;

// ----- Motion Estimation State -----
const G = 9.80665;                 // m/s^2 per 1g
let baselineCollecting = false;
let baselineReady = false;
let baselineSamples = [];          // samples during baseline (in g)
const BASELINE_SEC = 1.0;          // collect ~1s for baseline
const TARGET_FS = 200;             // Polar H10 ACC assumed @ 200 Hz
const BASELINE_COUNT = Math.round(BASELINE_SEC * TARGET_FS);

let baselineAcc = {x:0, y:0, z:0}; // in g
let vel = {x:0, y:0, z:0};         // m/s
let pos = {x:0, y:0, z:0};         // meters
let lastSampleTime = null;         // seconds

// 3D path (meters)
let motionPath3D = [];             // [{x,y,z}]
const MOTION_MAX_POINTS = 20000;   // cap to keep things fast
const VEL_DAMP_PER_SAMPLE = 0.98;  // crude damping to limit drift

// ================== UI Elements ==================
const connectBtn = document.getElementById('connectBtn');
const disconnectBtn = document.getElementById('disconnectBtn');
const saveAccBtn = document.getElementById('saveAccBtn');
const debugBtn = document.getElementById('debugBtn');
const retryBtn = document.getElementById('retryBtn');
const resetMotionBtn = document.getElementById('resetMotionBtn');
const statusEl = document.getElementById('status');

const accVal = document.getElementById('accVal');
const dataCountVal = document.getElementById('dataCountVal');
const collectionTimeVal = document.getElementById('collectionTimeVal');
const dataRateVal = document.getElementById('dataRateVal');
const motionDistVal = document.getElementById('motionDistVal');

// Canvas charts
const accxCanvas = document.getElementById('accxCanvas');
const accyCanvas = document.getElementById('accyCanvas');
const acczCanvas = document.getElementById('acczCanvas');
const accmCanvas = document.getElementById('accmCanvas');

// ================== 3D Scene ==================
const container3D = document.getElementById('motion3DContainer');
let renderer, scene, camera, controls;
let grid, axes, originMesh, currentMesh, pathLine;
let pathGeometry;

function init3D(){
  if (renderer) return; // already init

  // renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  container3D.appendChild(renderer.domElement);

  // scene & camera
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(50, 1, 0.01, 1000);
  camera.position.set(2.2, 1.4, 2.2);

  // controls
  controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.target.set(0,0,0);
  renderer.domElement.addEventListener('dblclick', ()=>{ controls.reset(); });

  // lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const dir = new THREE.DirectionalLight(0xffffff, 0.8);
  dir.position.set(2,3,4);
  scene.add(dir);

  // grid & axes (meters)
  grid = new THREE.GridHelper(4, 8);        // size, divisions
  grid.material.opacity = 0.2;
  grid.material.transparent = true;
  scene.add(grid);

  axes = new THREE.AxesHelper(1.5);
  scene.add(axes);

  // origin (centre) sphere ‚Äî green
  const originGeo = new THREE.SphereGeometry(0.035, 24, 24);
  const originMat = new THREE.MeshStandardMaterial({ color: 0x34d399, metalness: 0.1, roughness: 0.6 });
  originMesh = new THREE.Mesh(originGeo, originMat);
  originMesh.position.set(0,0,0);
  scene.add(originMesh);

  // current pos sphere ‚Äî amber
  const currGeo = new THREE.SphereGeometry(0.04, 24, 24);
  const currMat = new THREE.MeshStandardMaterial({ color: 0xf59e0b, emissive: 0x000000, metalness: 0.1, roughness: 0.5 });
  currentMesh = new THREE.Mesh(currGeo, currMat);
  currentMesh.position.set(0,0,0);
  scene.add(currentMesh);

  // path line
  pathGeometry = new THREE.BufferGeometry();
  const mat = new THREE.LineBasicMaterial({ color: 0x22d3ee, transparent: true, opacity: 0.9 });
  pathLine = new THREE.Line(pathGeometry, mat);
  scene.add(pathLine);

  // size + resize
  function resize(){
    const w = container3D.clientWidth;
    const h = container3D.clientHeight;
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h, false);
  }
  window.addEventListener('resize', resize);
  resize();

  // loop
  (function animate(){
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  })();
}

function update3DPath(){
  // Convert motionPath3D to Float32Array
  const n = motionPath3D.length;
  if (n < 2){
    pathGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
    pathGeometry.setDrawRange(0, 0);
    pathGeometry.computeBoundingSphere();
    return;
  }
  const arr = new Float32Array(n * 3);
  for (let i = 0; i < n; i++){
    const p = motionPath3D[i];
    arr[i*3+0] = p.x;
    arr[i*3+1] = p.y;
    arr[i*3+2] = p.z;
  }
  pathGeometry.setAttribute('position', new THREE.BufferAttribute(arr, 3));
  pathGeometry.setDrawRange(0, n);
  pathGeometry.computeBoundingSphere();

  // Auto-expand grid if we roam far: base on max radius
  const r = Math.max(
    Math.abs(pathGeometry.boundingSphere.center.x) + pathGeometry.boundingSphere.radius,
    Math.abs(pathGeometry.boundingSphere.center.y) + pathGeometry.boundingSphere.radius,
    Math.abs(pathGeometry.boundingSphere.center.z) + pathGeometry.boundingSphere.radius
  );
  const sizeNeeded = Math.max(2, Math.ceil(r) * 2);
  if (sizeNeeded > grid.geometry.parameters.size){
    scene.remove(grid);
    grid = new THREE.GridHelper(sizeNeeded, Math.max(8, sizeNeeded));
    grid.material.opacity = 0.2;
    grid.material.transparent = true;
    scene.add(grid);
  }
}

// ================== Helpers ==================
function setStatus(msg){ statusEl.textContent = msg; }

// --- Motion helpers ---
function resetMotion(){
  // clear current state and begin baseline collection
  baselineCollecting = true;
  baselineReady = false;
  baselineSamples = [];
  baselineAcc = {x:0,y:0,z:0};
  vel = {x:0,y:0,z:0};
  pos = {x:0,y:0,z:0};
  motionPath3D = [{x:0,y:0,z:0}];
  lastSampleTime = null;
  if (currentMesh){ currentMesh.position.set(0,0,0); }
  update3DPath();
  if (controls){ controls.target.set(0,0,0); }
  setStatus('Motion reset: hold steady ~1s to capture baseline‚Ä¶');
}

function addToBaseline(sampleG){
  baselineSamples.push({x:sampleG.x, y:sampleG.y, z:sampleG.z});
  if (baselineSamples.length >= BASELINE_COUNT){
    const sum = baselineSamples.reduce((a,s)=>({x:a.x+s.x, y:a.y+s.y, z:a.z+s.z}), {x:0,y:0,z:0});
    baselineAcc = {
      x: sum.x / baselineSamples.length,
      y: sum.y / baselineSamples.length,
      z: sum.z / baselineSamples.length
    };
    baselineCollecting = false;
    baselineReady = true;
    setStatus('Baseline captured. Tracking motion from (0,0,0).');
  }
}

function processMotionSample(sample, t){
  // sample: {x,y,z,m} in g ; t in seconds
  if (baselineCollecting){
    addToBaseline(sample);
    return;
  }
  if (!baselineReady) return; // wait for reset to calibrate

  if (lastSampleTime == null){
    lastSampleTime = t;
    return;
  }
  let dt = t - lastSampleTime;
  if (dt <= 0 || dt > 0.2){ // outliers / gaps
    dt = 1 / TARGET_FS;
  }
  lastSampleTime = t;

  // subtract baseline (g), convert to m/s^2
  const ax = (sample.x - baselineAcc.x) * G;
  const ay = (sample.y - baselineAcc.y) * G;
  const az = (sample.z - baselineAcc.z) * G;

  // integrate: v += a*dt
  vel.x += ax * dt;
  vel.y += ay * dt;
  vel.z += az * dt;

  // crude damping to limit runaway drift
  vel.x *= VEL_DAMP_PER_SAMPLE;
  vel.y *= VEL_DAMP_PER_SAMPLE;
  vel.z *= VEL_DAMP_PER_SAMPLE;

  // s += v*dt
  pos.x += vel.x * dt;
  pos.y += vel.y * dt;
  pos.z += vel.z * dt;

  // store
  motionPath3D.push({x: pos.x, y: pos.y, z: pos.z});
  if (motionPath3D.length > MOTION_MAX_POINTS) motionPath3D.shift();
}

// Reusable plot helper for 2D charts
function drawSeries(ctx, data, opts={}){
  const w = ctx.canvas.width, h = ctx.canvas.height;
  ctx.clearRect(0,0,w,h);
  ctx.save();
  ctx.translate(60,10);
  const iw = w - 70, ih = h - 50;
  ctx.strokeStyle = 'rgba(255,255,255,0.2)';
  ctx.lineWidth = 1;
  for (let i=0;i<5;i++){
    const y = 10 + i*(ih/4);
    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(iw,y); ctx.stroke();
  }
  for (let i=0;i<5;i++){
    const x = i*(iw/4);
    ctx.beginPath(); ctx.moveTo(x,10); ctx.lineTo(x,ih+10); ctx.stroke();
  }
  if (!data || data.x.length<2){ ctx.restore(); return; }
  const x = data.x, y = data.y;
  const xmin = Math.min(...x), xmax = Math.max(...x);
  const ymin = Math.min(...y), ymax = Math.max(...y);
  const sx = v => (v - xmin) / (xmax - xmin + 1e-9) * iw;
  const sy = v => ih - (v - ymin) / (ymax - ymin + 1e-9) * ih;
  const fmt = (val, range)=>{
    const r = Math.abs(range);
    if (!isFinite(r) || r < 1e-9) return val.toFixed(3);
    if (r < 0.5) return val.toFixed(3);
    if (r < 5) return val.toFixed(2);
    if (r < 50) return val.toFixed(1);
    return Math.round(val).toString();
  };
  ctx.fillStyle = 'rgba(148,163,184,0.95)';
  ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  for (let i=0;i<5;i++){
    const gy = 10 + i*(ih/4);
    const yval = ymax - (i/4)*(ymax - ymin);
    ctx.fillText(fmt(yval, ymax - ymin), -6, gy);
  }
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  for (let i=0;i<5;i++){
    const gx = i*(iw/4);
    const xval = xmin + (i/4)*(xmax - xmin);
    ctx.fillText(fmt(xval, xmax - xmin), gx, ih + 20);
  }
  ctx.strokeStyle = 'rgba(34,211,238,0.9)';
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(sx(x[0]), sy(y[0]));
  for (let i=1;i<x.length;i++) ctx.lineTo(sx(x[i]), sy(y[i]));
  ctx.stroke();
  ctx.restore();
}

// ================== BLE Parsing ==================
function parseAcc(dataView){
  const samples = [];
  if (dataView.byteLength < 10) return samples;

  const accuracy = dataView.getUint8(9);
  let sampleSize = 6;
  let offset = 10;
  if (accuracy === 0x00){ sampleSize = 3; }
  for (let i = offset; i + sampleSize - 1 < dataView.byteLength; i += sampleSize){
    let x,y,z;
    if (sampleSize === 3){
      x = dataView.getInt8(i) / 1000.0;
      y = dataView.getInt8(i+1) / 1000.0;
      z = dataView.getInt8(i+2) / 1000.0;
    } else {
      x = dataView.getInt16(i, true) / 1000.0;
      y = dataView.getInt16(i+2, true) / 1000.0;
      z = dataView.getInt16(i+4, true) / 1000.0;
    }
    const m = Math.sqrt(x*x + y*y + z*z);
    samples.push({x,y,z,m});
  }
  return samples;
}

function parsePMD(dataView){
  if (dataView.byteLength < 9) return null;
  const frametype = dataView.getUint8(0);
  const timestamp = dataView.getBigUint64(1, true);
  if (frametype === 0x02 || frametype === 0x00){
    const accSamples = parseAcc(dataView);
    if (accSamples.length) return {timestamp, accSamples};
  }
  return null;
}

function keepWindow(){
  while (accBuffer.length && accBuffer[0].t < accBuffer[accBuffer.length-1].t - WINDOW_SEC){ accBuffer.shift(); }
}

// ================== File Save & Debug ==================
function saveAccelerometerData(){
  if (!accBuffer || accBuffer.length === 0){
    alert('No accelerometer data to save');
    return;
  }
  let csvContent = 'timestamp,x,y,z,magnitude\n';
  accBuffer.forEach(sample => {
    csvContent += `${sample.t},${sample.x},${sample.y},${sample.z},${sample.m}\n`;
  });
  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `accelerometer_data_${new Date().toISOString().replace(/[:.]/g, '-')}.csv`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  setStatus(`Saved ${accBuffer.length} accelerometer samples to CSV file`);
}

function showDebugInfo(){
  console.log('=== DEBUG INFO ===');
  console.log('Device connected:', !!device);
  console.log('Server connected:', !!server);
  console.log('Data characteristic:', !!dataChar);
  console.log('Raw data frames received:', rawDataCount);
  console.log('Accelerometer buffer length:', accBuffer.length);
  console.log('Motion baselineReady:', baselineReady, 'collecting:', baselineCollecting);
  console.log('Baseline (g):', baselineAcc);
  console.log('Velocity (m/s):', vel);
  console.log('Position (m):', pos);
  alert(`Debug info logged to console. Check browser console (F12).
Raw frames: ${rawDataCount}
ACC samples: ${accBuffer.length}
Motion baseline: ${baselineReady ? 'ready' : (baselineCollecting ? 'collecting' : 'not set')}
`);
}

async function retryActivation(){
  if (!device || !server) { alert('Not connected to device'); return; }
  setStatus('Retrying activation methods‚Ä¶');
  try {
    const pmdSvc = await server.getPrimaryService(PMD_SERVICE_UUID);
    const ctrlChar = await pmdSvc.getCharacteristic(PMD_CHAR1_UUID);
    rawDataCount = 0;
    await ctrlChar.writeValueWithoutResponse(ACC_WRITE);
    await new Promise(r => setTimeout(r, 1000));
    const altCommand = new Uint8Array([0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00]);
    await ctrlChar.writeValueWithoutResponse(altCommand);
    await new Promise(r => setTimeout(r, 1000));
    const combined = new Uint8Array([0x02,0x00,0x00,0x01,0x82,0x00,0x01,0x01,0x0E,0x00, 0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00, 0x02,0x01,0x08,0x00]);
    await ctrlChar.writeValueWithoutResponse(combined);
    setStatus('Retry complete. Check console for results‚Ä¶');
    setTimeout(()=>{ setStatus(rawDataCount>0 ? `Success! Received ${rawDataCount} frames` : 'Retry failed. Try reconnecting.'); }, 3000);
  } catch (err) {
    console.error('Retry failed:', err);
    setStatus('Retry failed: ' + err.message);
  }
}

// ================== UI Refresh ==================
function updateUI(){
  // Acc magnitude
  if (accBuffer.length > 0){
    const latest = accBuffer[accBuffer.length - 1];
    accVal.innerHTML = `${latest.m.toFixed(2)} <small>g</small>`;
  } else {
    accVal.innerHTML = '‚Äî <small>g</small>';
  }

  // Motion distance (3D, straight-line)
  if (motionPath3D.length){
    const p = motionPath3D[motionPath3D.length-1];
    const dist = Math.hypot(p.x, p.y, p.z);
    motionDistVal.innerHTML = `${dist.toFixed(2)} <small>m</small>`;
    if (currentMesh) currentMesh.position.set(p.x, p.y, p.z);
    update3DPath();
  } else {
    motionDistVal.innerHTML = '0.00 <small>m</small>';
  }

  // Data count
  dataCountVal.innerHTML = `${accBuffer.length} <small>samples</small>`;

  // Collection time
  if (startTime) {
    const elapsed = (Date.now() / 1000) - startTime;
    const minutes = Math.floor(elapsed / 60);
    collectionTimeVal.innerHTML = `${minutes} <small>minutes</small>`;
  } else {
    collectionTimeVal.innerHTML = '0 <small>minutes</small>';
  }

  // Data rate
  const currentTime = Date.now() / 1000;
  if (lastDataTime > 0 && currentTime > lastDataTime) {
    const timeDiff = currentTime - lastDataTime;
    const dataDiff = accBuffer.length - lastDataCount;
    const dataRate = dataDiff / timeDiff;
    dataRateVal.innerHTML = `${dataRate.toFixed(1)} <small>Hz</small>`;
  } else {
    dataRateVal.innerHTML = '0.0 <small>Hz</small>';
  }
  lastDataCount = accBuffer.length;
  lastDataTime = currentTime;

  // ACC plots
  if (accBuffer.length >= 2){
    const t = accBuffer.map(p => p.t);
    drawSeries(accxCanvas.getContext('2d'), { x:t, y:accBuffer.map(p=>p.x) });
    drawSeries(accyCanvas.getContext('2d'), { x:t, y:accBuffer.map(p=>p.y) });
    drawSeries(acczCanvas.getContext('2d'), { x:t, y:accBuffer.map(p=>p.z) });
    drawSeries(accmCanvas.getContext('2d'), { x:t, y:accBuffer.map(p=>p.m) });
  } else {
    const ctxs = [accxCanvas, accyCanvas, acczCanvas, accmCanvas].map(c=>c.getContext('2d'));
    ctxs.forEach(ctx=> drawSeries(ctx, {x:[], y:[]}) );
  }
}

// ================== BLE Flow ==================
async function connect(){
  try{
    init3D();

    setStatus('Requesting device‚Ä¶');
    device = await navigator.bluetooth.requestDevice({
      filters: [{ name: 'Polar H10' }, { namePrefix: 'Polar' }],
      optionalServices: [HR_SERVICE_UUID, PMD_SERVICE_UUID],
      acceptAllDevices: false
    });

    device.addEventListener('gattserverdisconnected', onDisconnected);
    setStatus('Connecting‚Ä¶');

    const connectPromise = device.gatt.connect();
    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), 10000));
    server = await Promise.race([connectPromise, timeoutPromise]);

    setStatus('Getting services‚Ä¶');

    try { await server.getPrimaryService('0000180a-0000-1000-8000-00805f9b34fb'); } catch {}

    const pmdSvc = await server.getPrimaryService(PMD_SERVICE_UUID);
    const ctrlChar = await pmdSvc.getCharacteristic(PMD_CHAR1_UUID);

    setStatus('Starting accelerometer data stream‚Ä¶');

    try {
      const hrSvc = await server.getPrimaryService(HR_SERVICE_UUID);
      const hrChar = await hrSvc.getCharacteristic(HR_MEAS_UUID);
      try { await hrChar.startNotifications(); setTimeout(()=>{ try{ hrChar.stopNotifications(); }catch{} }, 1000); } catch {}
    } catch {}

    await ctrlChar.writeValueWithoutResponse(ACC_WRITE);
    await new Promise(r => setTimeout(r, 1000));
    await ctrlChar.writeValueWithoutResponse(ACC_WRITE);
    await new Promise(r => setTimeout(r, 2000));

    const pmdChar2 = await pmdSvc.getCharacteristic(PMD_CHAR2_UUID);
    dataChar = pmdChar2;
    dataChar.addEventListener('characteristicvaluechanged', onPMD);
    await dataChar.startNotifications();
    await new Promise(r => setTimeout(r, 1000));

    setStatus('Connected. Streaming accelerometer data‚Ä¶');
    connectBtn.disabled = true;
    disconnectBtn.disabled = false;
    retryBtn.disabled = false;
    resetMotionBtn.disabled = false;
    startTime = Date.now() / 1000;

    // Start timers
    if (updateTimer) clearInterval(updateTimer);
    if (uiTimer) clearInterval(uiTimer);
    updateTimer = setInterval(processStep, 1000);
    uiTimer = setInterval(updateUI, 100);

    // Auto-initialize motion baseline once connected
    resetMotion();

    // Fallback activation attempts if no data
    setTimeout(async () => {
      if (rawDataCount === 0) {
        setStatus('Connected but no data yet. Trying alternative activation‚Ä¶');
        const alt = new Uint8Array([0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00]);
        try { await ctrlChar.writeValueWithoutResponse(alt); } catch {}
        setTimeout(async ()=>{
          const combined = new Uint8Array([0x02,0x00,0x00,0x01,0x82,0x00,0x01,0x01,0x0E,0x00, 0x02,0x02,0x00,0x01,0xC8,0x00,0x01,0x01,0x10,0x00, 0x02,0x01,0x08,0x00]);
          try { await ctrlChar.writeValueWithoutResponse(combined); } catch {}
        }, 1000);
      }
    }, 5000);

  } catch(err){
    console.error(err);
    if (err.name === 'NotFoundError') setStatus('Error: No Polar H10 found. Make sure it\'s nearby and advertising.');
    else if (err.name === 'SecurityError') setStatus('Error: Bluetooth access denied.');
    else if (err.message === 'Connection timeout') setStatus('Error: Connection timeout.');
    else setStatus('Error: ' + err.message);
    throw err; // allow retry wrapper to handle
  }
}

function onDisconnected(){
  setStatus('Disconnected');
  connectBtn.disabled = false;
  disconnectBtn.disabled = true;
  retryBtn.disabled = true;
  resetMotionBtn.disabled = true;
  if (dataChar){ try{ dataChar.stopNotifications(); } catch(e){} }
  if (updateTimer) clearInterval(updateTimer);
  if (uiTimer) clearInterval(uiTimer);
}

async function disconnect(){
  try{
    if (!device) return;
    if (dataChar){ try{ await dataChar.stopNotifications(); } catch(e){} }
    if (device.gatt.connected) device.gatt.disconnect();
  } catch(err){ console.error(err); }
}

function onPMD(event){
  const dv = event.target.value;
  rawDataCount++;
  const data = parsePMD(dv);
  if (!data) return;

  const tNow = Number(data.timestamp) / 1e9;
  const n = data.accSamples.length;

  for (let i = 0; i < n; i++){
    const s = data.accSamples[i];
    const t = tNow - (n - i - 1) / TARGET_FS; // spread samples evenly at 200 Hz
    // store for ACC plots/CSV
    accBuffer.push({ t, x:s.x, y:s.y, z:s.z, m:s.m });
    // update motion live
    processMotionSample(s, t);
  }
}

function processStep(){
  keepWindow();
}

// ================== Events ==================
connectBtn.addEventListener('click', connectWithRetry);
disconnectBtn.addEventListener('click', disconnect);
saveAccBtn.addEventListener('click', saveAccelerometerData);
debugBtn.addEventListener('click', showDebugInfo);
retryBtn.addEventListener('click', retryActivation);
resetMotionBtn.addEventListener('click', resetMotion);

// Feature detection and macOS guidance
if (!('bluetooth' in navigator)){
  setStatus('Web Bluetooth not available in this browser. Try Chrome or Edge.');
  connectBtn.disabled = true;
} else {
  const isMac = navigator.platform.toUpperCase().includes('MAC');
  setStatus(isMac ? 'Ready. On macOS, ensure Bluetooth is enabled and H10 is paired.' : 'Ready. Make sure Bluetooth is enabled and H10 is nearby.');
}

// Connection retry wrapper
let connectionRetries = 0;
const maxRetries = 3;
async function connectWithRetry() {
  try {
    await connect();
    connectionRetries = 0;
  } catch (err) {
    connectionRetries++;
    if (connectionRetries < maxRetries) {
      setStatus(`Connection failed. Retrying‚Ä¶ (${connectionRetries}/${maxRetries})`);
      setTimeout(connectWithRetry, 2000);
    } else {
      setStatus('Connection failed after multiple attempts. Please check device and try again.');
      connectionRetries = 0;
    }
  }
}
</script>
</body>
</html>
